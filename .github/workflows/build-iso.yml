name: Build Lyrah OS ISO

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - testing
          - dev

env:
  FEDORA_VERSION: 43
  BASE_ISO_URL: https://download.fedoraproject.org/pub/fedora/linux/releases/43/KDE/x86_64/iso/Fedora-KDE-Desktop-Live-43-1.6.x86_64.iso

jobs:
  build-iso:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          sudo rm -rf /usr/share/swift /usr/share/miniconda /usr/share/az_* /opt/hostedtoolcache
          sudo docker image prune -af 2>/dev/null || true
          echo "Available disk space:"
          sudo df -h /

      - name: Determine build variant
        id: variant
        run: |
          BRANCH="${{ github.ref_name }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH="${{ inputs.branch }}"
          fi

          case $BRANCH in
            main)
              echo "variant=main" >> $GITHUB_OUTPUT
              echo "version=1.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
            testing)
              echo "variant=testing" >> $GITHUB_OUTPUT
              echo "version=1.0-beta.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "variant=dev" >> $GITHUB_OUTPUT
              echo "version=1.0-dev.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            genisoimage \
            xorriso \
            squashfs-tools \
            isolinux \
            dosfstools \
            wget \
            rsync \
            zstd \
            lz4

      - name: Download base Fedora KDE ISO
        run: |
          echo "Downloading Fedora KDE Live ISO..."
          wget -O fedora-base.iso "${{ env.BASE_ISO_URL }}"
          ls -lh fedora-base.iso

      - name: Extract ISO contents
        id: extract-iso
        run: |
          echo "Extracting ISO..."
          mkdir -p iso-extract iso-build
          sudo mount -o loop fedora-base.iso iso-extract
          sudo rsync -av iso-extract/ iso-build/
          sudo umount iso-extract
          sudo chmod -R u+w iso-build/
          # Free disk: remove base ISO now that contents are extracted
          rm -f fedora-base.iso
          # Remove the squashfs/rootfs image — we build rootfs from scratch
          # with dnf --installroot instead of extracting from EROFS/SquashFS.
          # Only the boot infrastructure (EFI, grub, isolinux) is kept.
          sudo rm -f iso-build/LiveOS/squashfs.img iso-build/LiveOS/rootfs.img 2>/dev/null || true
          echo "Disk after ISO extraction (rootfs images removed):"
          df -h /

          # List ISO boot infrastructure so we can see what's available.
          # Fedora 43+ may be UEFI-only (no isolinux directory).
          echo "=== Extracted ISO directory structure (boot files) ==="
          echo "--- Top-level directories ---"
          ls -la iso-build/
          echo "--- EFI directory ---"
          find iso-build/EFI -type f 2>/dev/null || echo "(no EFI directory)"
          echo "--- images directory ---"
          find iso-build/images -type f 2>/dev/null || echo "(no images directory)"
          echo "--- isolinux directory ---"
          find iso-build/isolinux -type f 2>/dev/null || echo "(no isolinux directory)"
          echo "--- boot directory ---"
          find iso-build/boot -type f 2>/dev/null || echo "(no boot directory)"
          echo "--- All .img files ---"
          find iso-build/ -name "*.img" -type f 2>/dev/null || echo "(no .img files)"
          echo "--- All .efi files ---"
          find iso-build/ -name "*.efi" -o -name "*.EFI" 2>/dev/null || echo "(no .efi files)"
          echo "=== End directory listing ==="

          # Detect kernel version from ISO boot area.
          # Phase 2 must install this EXACT version so modules match the
          # vmlinuz that GRUB actually boots. A mismatch means no runtime
          # module loading (no GPU drivers, no network, no sound).
          ISO_KVER=""
          for vmlinuz_path in iso-build/images/pxeboot/vmlinuz iso-build/isolinux/vmlinuz iso-build/boot/x86_64/loader/linux; do
            if [ -f "$vmlinuz_path" ]; then
              ISO_KVER=$(file "$vmlinuz_path" | grep -oP 'version \K\S+' || true)
              if [ -n "$ISO_KVER" ]; then
                echo "Detected ISO boot kernel: $ISO_KVER"
                break
              fi
            fi
          done
          if [ -z "$ISO_KVER" ]; then
            echo "WARNING: Could not detect ISO kernel version — phase 2 will install latest"
          fi
          echo "iso_kver=${ISO_KVER}" >> $GITHUB_OUTPUT

      # Replace Fedora Plymouth theme in the boot area initramfs with Lyrah theme.
      # The live ISO uses the base Fedora initramfs from iso-build/isolinux/ and
      # iso-build/images/pxeboot/, which has the Fedora theme embedded. This step
      # extracts the initramfs, replaces the Fedora theme with Lyrah, and repacks it.
      - name: Customize boot area Plymouth theme
        run: |
          set -euo pipefail
          echo "=== Customizing Plymouth theme in boot initramfs ==="

          # Function to extract, modify, and repack an initramfs
          customize_initramfs() {
            local initramfs_path="$1"

            if [ ! -f "$initramfs_path" ]; then
              echo "WARN: $initramfs_path not found, skipping"
              return 0
            fi

            echo "Processing: $initramfs_path"

            # Create temporary directory for extraction
            local work_dir=$(mktemp -d)
            cd "$work_dir"

            # Detect compression and extract.
            # Fedora 43+ commonly uses zstd-compressed initramfs; if we don't
            # handle that format, Fedora branding stays in place.
            initramfs_file_info=$(file "$initramfs_path")
            if echo "$initramfs_file_info" | grep -qi "zstd"; then
              echo "  Detected zstd compression"
              zstd -dc "$initramfs_path" | cpio -idm --quiet
            elif echo "$initramfs_file_info" | grep -qi "gzip"; then
              echo "  Detected gzip compression"
              gunzip -c "$initramfs_path" | cpio -idm --quiet
            elif echo "$initramfs_file_info" | grep -qi "XZ"; then
              echo "  Detected XZ compression"
              xz -dc "$initramfs_path" | cpio -idm --quiet
            elif echo "$initramfs_file_info" | grep -qi "LZ4"; then
              echo "  Detected LZ4 compression"
              lz4 -dc "$initramfs_path" | cpio -idm --quiet
            else
              echo "  Extracting as plain cpio"
              cpio -idm --quiet < "$initramfs_path"
            fi

            # Check if Plymouth theme directory exists
            if [ -d usr/share/plymouth/themes ]; then
              echo "  Found Plymouth themes directory"

              # Remove Fedora themes
              sudo rm -rf usr/share/plymouth/themes/fedora* usr/share/plymouth/themes/spinner 2>/dev/null || true
              echo "  Removed Fedora themes"

              # Add Lyrah theme
              mkdir -p usr/share/plymouth/themes/lyrah
              cp -r "${GITHUB_WORKSPACE}/themes/plymouth/lyrah/"* usr/share/plymouth/themes/lyrah/
              echo "  Added Lyrah theme"

              # Update plymouthd.conf if it exists
              if [ -f etc/plymouth/plymouthd.conf ]; then
                sed -i 's/^Theme=.*/Theme=lyrah/' etc/plymouth/plymouthd.conf
                echo "  Updated plymouthd.conf to use Lyrah theme"
              else
                # Create config if it doesn't exist
                mkdir -p etc/plymouth
                echo "[Daemon]" > etc/plymouth/plymouthd.conf
                echo "Theme=lyrah" >> etc/plymouth/plymouthd.conf
                echo "  Created plymouthd.conf with Lyrah theme"
              fi
            else
              echo "  WARN: No Plymouth themes directory found in initramfs"
            fi

            # Repack the initramfs (using gzip compression like Fedora does)
            echo "  Repacking initramfs..."
            find . -print0 | cpio -0 -o -H newc --quiet 2>/dev/null | gzip -9 > "${work_dir}/initramfs.new"

            # Replace original
            sudo cp "${work_dir}/initramfs.new" "$initramfs_path"
            echo "  Replaced $initramfs_path"

            # Cleanup
            cd /
            rm -rf "$work_dir"
            echo "  Done processing $initramfs_path"
          }

          # Process BIOS/isolinux initramfs
          customize_initramfs "${GITHUB_WORKSPACE}/iso-build/isolinux/initrd.img"

          # Process PXE boot initramfs if it exists
          customize_initramfs "${GITHUB_WORKSPACE}/iso-build/images/pxeboot/initrd.img"

          # Process UEFI-only boot initramfs (Fedora 43+ KDE uses this path)
          customize_initramfs "${GITHUB_WORKSPACE}/iso-build/boot/x86_64/loader/initrd"

          echo "=== Plymouth theme customization complete ==="

      # Swap must be expanded BEFORE rootfs build — the default runner swap
      # (3GB) is not enough for dnf dependency resolution of large package sets.
      - name: Ensure adequate swap space
        run: |
          CURRENT_SWAP_KB=$(swapon --show=SIZE --bytes --noheadings 2>/dev/null | awk '{s+=$1} END{print int(s/1024)}')
          echo "Current swap: ${CURRENT_SWAP_KB:-0} KB"
          NEED_KB=$((8 * 1024 * 1024))
          if [ "${CURRENT_SWAP_KB:-0}" -lt "$NEED_KB" ]; then
            echo "Expanding swap to 8GB..."
            sudo swapoff -a 2>/dev/null || true
            sudo rm -f /swapfile /mnt/swapfile
            sudo fallocate -l 8G /mnt/swapfile
            sudo chmod 600 /mnt/swapfile
            sudo mkswap /mnt/swapfile
            sudo swapon /mnt/swapfile
          else
            echo "Existing swap is sufficient"
          fi
          free -h

      # Build rootfs from scratch using dnf --installroot instead of
      # extracting from the Fedora ISO's EROFS/SquashFS image.
      #
      # The old approach mounted the EROFS image, which triggered OOM:
      # the kernel EROFS driver allocates non-swappable slab memory for
      # BIG_PCLUSTER decompression, exceeding the runner's cgroup limit.
      #
      # dnf --installroot avoids this entirely — it downloads and installs
      # packages in userspace with normal swappable memory.
      #
      # Phase 1: Install everything EXCEPT kernel* to keep peak memory low.
      # Phase 2: Install kernel in a separate pass after phase 1 memory is freed.
      - name: Build rootfs (phase 1 - base system, no kernel)
        run: |
          set -euo pipefail
          echo "Building rootfs from scratch using dnf --installroot..."
          echo "Phase 1: base system (excluding kernel* to avoid OOM)"
          sudo mkdir -p squashfs-root

          echo "=== Memory before phase 1 ==="
          free -h
          echo "==="

          # Use a Fedora container to run dnf --installroot.
          # The container provides Fedora repo configs; --installroot creates
          # a fresh Fedora root filesystem at the mounted /rootfs path.
          # Excluding kernel* drastically reduces peak memory — the kernel
          # package tree is the single largest contributor to dnf metadata bloat.
          # --use-host-config is REQUIRED for dnf5 (Fedora 41+).
          # Without it, dnf5 looks for repos inside the empty installroot
          # and resolves nothing. This flag tells it to use the container's
          # /etc/yum.repos.d/ and /etc/dnf/dnf.conf instead.
          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c '
              set -euo pipefail

              # Enable RPM Fusion repos (needed for steam, dxvk, etc.)
              dnf install -y \
                https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-${{ env.FEDORA_VERSION }}.noarch.rpm \
                https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-${{ env.FEDORA_VERSION }}.noarch.rpm

              # Add Brave browser repo
              dnf install -y dnf-plugins-core
              dnf config-manager addrepo --from-repofile=https://brave-browser-rpm-release.s3.brave.com/brave-browser.repo
              rpm --import https://brave-browser-rpm-release.s3.brave.com/brave-core.asc

              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                --exclude=kernel \
                --exclude=kernel-core \
                --exclude=kernel-modules \
                --exclude=kernel-modules-core \
                --exclude=kernel-modules-extra \
                --exclude=kernel-devel \
                --exclude=kernel-debug* \
                --exclude=virtualbox-guest-additions* \
                --exclude=dolphin \
                filesystem \
                setup \
                @kde-desktop-environment \
                thunar \
                NetworkManager \
                NetworkManager-wifi \
                wpa_supplicant \
                linux-firmware \
                pipewire \
                wireplumber \
                sddm \
                gamemode \
                mangohud \
                gamescope \
                steam \
                lutris \
                wine \
                winetricks \
                protontricks \
                corectrl \
                brave-browser \
                mesa-dri-drivers \
                mesa-dri-drivers.i686 \
                mesa-vulkan-drivers \
                mesa-vulkan-drivers.i686 \
                mesa-va-drivers \
                mesa-libEGL \
                mesa-libGL \
                mesa-libgbm \
                mesa-libglapi \
                libglvnd-egl \
                libglvnd-glx \
                libglvnd-gles \
                libdrm \
                libva \
                libva-utils \
                vulkan-loader \
                vulkan-loader.i686 \
                glibc.i686 \
                alsa-lib.i686 \
                libXinerama.i686 \
                xdg-desktop-portal \
                xdg-desktop-portal-kde \
                flatpak \
                plasma-discover-flatpak \
                plasma-discover-packagekit \
                PackageKit \
                polkit \
                polkit-kde-agent-1 \
                appstream-data \
                logrotate \
                grub2-efi-x64 \
                grub2-efi-x64-modules \
                efibootmgr \
                shim-x64 \
                plymouth \
                dracut \
                dracut-live \
                systemd \
                dnf \
                passwd \
                sudo \
                bash \
                glibc-langpack-en \
                util-linux

              dnf clean all --installroot=/rootfs

              # Verify install actually wrote files
              if [ ! -x /rootfs/usr/bin/bash ]; then
                echo "FATAL: /usr/bin/bash missing after dnf install — rootfs is empty"
                ls -la /rootfs/ || true
                exit 1
              fi
              echo "Rootfs verified inside container: /usr/bin/bash exists"
            '

          echo "Phase 1 complete. Rootfs size: $(sudo du -sh squashfs-root/ | cut -f1)"
          echo "Memory after phase 1:"
          free -h
          echo "Disk after phase 1:"
          df -h /

      - name: Install kernel into rootfs (phase 2)
        run: |
          set -euo pipefail
          echo "Phase 2: Installing kernel (separate pass to avoid OOM)..."

          echo "=== Memory before phase 2 ==="
          free -h
          echo "==="

          # Separate container run so phase 1 memory is fully released.
          # Only the kernel package tree is resolved here — much smaller
          # dependency graph than the full system.
          #
          # Use kernel-core + kernel-modules-core instead of the 'kernel'
          # meta-package. The meta-package triggers kernel-install hooks
          # that write to /boot and run grub2-mkconfig — all pointless
          # inside --installroot since boot infrastructure comes from the
          # base Fedora ISO. We only need modules for runtime hardware support.
          #
          # Pin to the ISO's kernel version so modules match the vmlinuz
          # that GRUB actually boots. A version mismatch means modprobe
          # can't find modules at runtime (no GPU, no network, no sound).
          ISO_KVER="${{ steps.extract-iso.outputs.iso_kver }}"
          KERNEL_PKGS="kernel-core kernel-modules kernel-modules-core"
          if [ -n "$ISO_KVER" ]; then
            # file reports: 6.x.y-z.fc43.x86_64 — strip arch suffix for dnf
            KVER_DNF="${ISO_KVER%.x86_64}"
            KVER_DNF="${KVER_DNF%.aarch64}"
            echo "Pinning kernel to ISO version: $KVER_DNF"
            KERNEL_PKGS="kernel-core-${KVER_DNF} kernel-modules-${KVER_DNF} kernel-modules-core-${KVER_DNF}"
          else
            echo "WARNING: ISO kernel version unknown — installing latest"
          fi

          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c "
              set -euo pipefail

              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                $KERNEL_PKGS

              dnf clean all --installroot=/rootfs

              # Verify kernel modules were installed
              ls /rootfs/lib/modules/ || {
                echo 'FATAL: No kernel modules found after dnf install'
                exit 1
              }

              # Run depmod to ensure modprobe can find all modules.
              # The RPM %post may not run it correctly inside --installroot.
              INSTALLED_KVER=\$(ls /rootfs/lib/modules/ | sort -V | tail -1)
              if [ -n \"\$INSTALLED_KVER\" ]; then
                chroot /rootfs depmod \"\$INSTALLED_KVER\" 2>&1 || echo 'WARN: depmod failed'
                echo \"Ran depmod for kernel \$INSTALLED_KVER\"
              fi
            "

          echo "Phase 2 complete. Rootfs size: $(sudo du -sh squashfs-root/ | cut -f1)"
          echo "Kernel modules installed:"
          ls squashfs-root/lib/modules/ 2>/dev/null || echo "WARNING: No kernel modules found"
          echo "Memory after phase 2:"
          free -h
          echo "Disk after phase 2:"
          df -h /
          echo "Root entries:"
          ls squashfs-root/ | head -20

      # Install Calamares in its own container run (phase 3).
      # Previously Calamares was installed inside the phase 1 container,
      # but after resolving 800+ base packages, dnf OOMs or hits conflicts
      # on the second resolution. Running in a separate container frees all
      # phase 1 memory before starting. This mirrors the kernel approach.
      - name: Install Calamares into rootfs (phase 3)
        run: |
          set -euo pipefail
          echo "Phase 3: Installing Calamares installer..."

          echo "=== Memory before phase 3 ==="
          free -h
          echo "==="

          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c '
              set -euo pipefail

              echo "Installing Calamares..."
              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                --exclude=kernel \
                --exclude=kernel-core \
                --exclude=kernel-modules \
                --exclude=kernel-modules-core \
                --exclude=kernel-modules-extra \
                --exclude=kernel-devel \
                --exclude=kernel-debug* \
                --exclude=virtualbox-guest-additions* \
                calamares

              dnf clean all --installroot=/rootfs

              # Hard verification: calamares binary must exist
              if [ ! -f /rootfs/usr/bin/calamares ]; then
                echo "FATAL: /usr/bin/calamares not found after install"
                echo "Contents of /usr/bin/calam*:"
                ls -la /rootfs/usr/bin/calam* 2>/dev/null || echo "  (none)"
                echo "RPM query:"
                rpm --root=/rootfs -q calamares 2>/dev/null || echo "  calamares not in rpm db"
                exit 1
              fi
              echo "Calamares verified: $(ls -la /rootfs/usr/bin/calamares)"
            '

          echo "Phase 3 complete. Calamares installed."
          echo "Memory after phase 3:"
          free -h

      # Build luna-ui (the gaming frontend) from source.
      # luna-ui is not published to Copr yet, so we compile it during the
      # ISO build. Build dependencies stay in the container; only the
      # binary and resources are installed into the rootfs.
      - name: Build luna-ui from source (phase 4)
        run: |
          set -euo pipefail
          echo "Phase 4: Building luna-ui from source..."

          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            -v "$(pwd)/luna-ui:/src/luna-ui:ro" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c '
              set -euo pipefail

              echo "Installing luna-ui build dependencies..."
              dnf install -y \
                cmake gcc-c++ \
                qt6-qtbase-devel qt6-qtdeclarative-devel \
                SDL2-devel sqlite-devel

              echo "Building luna-ui..."
              mkdir /build && cd /build
              cmake /src/luna-ui -DCMAKE_INSTALL_PREFIX=/usr
              cmake --build . -j$(nproc)

              echo "Installing luna-ui into rootfs..."
              DESTDIR=/rootfs cmake --install .

              # Verify binary was installed
              if [ ! -f /rootfs/usr/bin/luna-ui ]; then
                echo "FATAL: luna-ui binary not found after install"
                exit 1
              fi
              echo "luna-ui installed: $(ls -la /rootfs/usr/bin/luna-ui)"
              echo "Resources:"
              ls -la /rootfs/usr/share/luna-ui/ 2>/dev/null || echo "  (no resources dir)"
            '

          echo "Phase 4 complete. luna-ui built and installed."

      # Copy Lyrah OS configs into rootfs before chroot
      - name: Stage Lyrah OS files
        run: |
          echo "Staging Lyrah OS files into rootfs..."

          # Calamares config and branding
          sudo mkdir -p squashfs-root/etc/calamares
          sudo cp -r installer/calamares/settings.conf squashfs-root/etc/calamares/
          sudo cp -r installer/calamares/modules squashfs-root/etc/calamares/
          sudo mkdir -p squashfs-root/usr/share/calamares/branding/lyrah
          sudo cp -r installer/calamares/branding/lyrah/* squashfs-root/usr/share/calamares/branding/lyrah/

          # Session desktop files
          sudo mkdir -p squashfs-root/usr/share/wayland-sessions
          sudo cp configs/luna-mode/luna-mode.desktop squashfs-root/usr/share/wayland-sessions/
          sudo cp configs/desktop-mode/plasma.desktop squashfs-root/usr/share/wayland-sessions/

          # SDDM theme
          sudo mkdir -p squashfs-root/usr/share/sddm/themes/lyrah-space
          sudo cp -r themes/sddm/lyrah-space/* squashfs-root/usr/share/sddm/themes/lyrah-space/

          # SDDM config (lyrah theme as default)
          sudo mkdir -p squashfs-root/etc/sddm.conf.d
          sudo cp configs/common/lyrah.conf squashfs-root/etc/sddm.conf.d/lyrah.conf

          # Plymouth theme
          sudo mkdir -p squashfs-root/usr/share/plymouth/themes/lyrah
          sudo cp -r themes/plymouth/lyrah/* squashfs-root/usr/share/plymouth/themes/lyrah/
          # Set Lyrah as the default Plymouth theme. This updates
          # /etc/plymouth/plymouthd.conf inside the squashfs. We don't
          # rebuild initramfs here (the live ISO uses Fedora's initramfs
          # from the boot area), but this ensures the theme is active for
          # the installed system and any live boot Plymouth displays.
          sudo chroot squashfs-root /bin/bash -c "plymouth-set-default-theme lyrah" 2>/dev/null || echo "WARN: Could not set Plymouth theme (non-fatal)"

          # Scripts
          sudo mkdir -p squashfs-root/usr/share/lyrah/setup
          sudo cp scripts/first-boot.sh squashfs-root/usr/share/lyrah/setup/
          sudo cp scripts/configure-gpu.sh squashfs-root/usr/share/lyrah/setup/
          sudo cp scripts/detect-primary-gpu.sh squashfs-root/usr/share/lyrah/setup/
          sudo cp scripts/lyrah-kwin-wrapper.sh squashfs-root/usr/share/lyrah/setup/
          sudo chmod +x squashfs-root/usr/share/lyrah/setup/*.sh

          sudo mkdir -p squashfs-root/usr/bin
          sudo cp scripts/luna-session squashfs-root/usr/bin/
          sudo cp scripts/lyrah-installer-session squashfs-root/usr/bin/
          sudo cp scripts/lyrah-switch-mode squashfs-root/usr/bin/
          sudo cp scripts/lyrah-configure-autologin squashfs-root/usr/bin/
          sudo cp scripts/lyrah-update squashfs-root/usr/bin/
          sudo cp scripts/lyrah-upload-log squashfs-root/usr/bin/
          sudo cp scripts/lyrah-crash-monitor squashfs-root/usr/bin/
          sudo chmod +x squashfs-root/usr/bin/luna-session squashfs-root/usr/bin/lyrah-*

          # Installer session .desktop (SDDM can select this as a session)
          sudo cp installer/lyrah-installer.desktop squashfs-root/usr/share/wayland-sessions/

          # Set Thunar as default file manager (replacing Dolphin)
          sudo mkdir -p squashfs-root/etc/skel/.config
          sudo tee squashfs-root/etc/skel/.config/mimeapps.list > /dev/null << 'MIME_EOF'
          [Default Applications]
          inode/directory=thunar.desktop
          MIME_EOF
          # Also set system-wide default
          sudo mkdir -p squashfs-root/usr/share/applications
          sudo tee squashfs-root/usr/share/applications/mimeapps.list > /dev/null << 'MIME_EOF'
          [Default Applications]
          inode/directory=thunar.desktop
          MIME_EOF

          # Systemd units
          sudo cp system/*.service system/*.timer squashfs-root/etc/systemd/system/ 2>/dev/null || true

          # Save signed EFI binaries from the grub2-efi-x64 and shim-x64
          # RPMs. These are the Fedora-signed grubx64.efi and shimx64.efi
          # that work with Secure Boot. We save them to a non-EFI location
          # so our install-bootloader.sh can use them during installation
          # (grub2-install may fail inside the Calamares chroot, and its
          # output is unsigned anyway).
          sudo mkdir -p squashfs-root/usr/share/lyrah/efi-binaries
          for efi_bin in grubx64.efi shimx64.efi shimx64-fedora.efi mmx64.efi; do
            if [ -f "squashfs-root/boot/efi/EFI/fedora/$efi_bin" ]; then
              sudo cp "squashfs-root/boot/efi/EFI/fedora/$efi_bin" squashfs-root/usr/share/lyrah/efi-binaries/
              echo "Saved $efi_bin for bootloader installation"
            fi
          done
          # Now remove the Fedora EFI directory. If these ship in the
          # squashfs, Calamares copies them to the real ESP and the firmware
          # shows a duplicate "Fedora" boot entry with stale UUIDs.
          sudo rm -rf squashfs-root/boot/efi/EFI/fedora
          echo "Removed stale Fedora EFI directory from rootfs"

          # Verify EFI binaries were actually saved — if not, the installed
          # system won't be bootable. Also check alternate RPM install locations.
          if [ ! -f "squashfs-root/usr/share/lyrah/efi-binaries/grubx64.efi" ]; then
            echo "WARN: grubx64.efi not found at /boot/efi/EFI/fedora/"
            echo "Searching for grubx64.efi in alternate locations..."
            # Fedora may install the signed binary elsewhere
            for alt_path in \
              "squashfs-root/usr/lib/grub/x86_64-efi/grubx64.efi" \
              "squashfs-root/boot/efi/EFI/BOOT/grubx64.efi"; do
              if [ -f "$alt_path" ]; then
                sudo cp "$alt_path" squashfs-root/usr/share/lyrah/efi-binaries/grubx64.efi
                echo "Found and saved grubx64.efi from $alt_path"
                break
              fi
            done
            # Last resort: build one from GRUB modules if available
            if [ ! -f "squashfs-root/usr/share/lyrah/efi-binaries/grubx64.efi" ]; then
              echo "WARN: No prebuilt grubx64.efi found — install-bootloader.sh will try grub2-mkimage at install time"
            fi
          fi
          echo "=== EFI binaries in squashfs ==="
          ls -la squashfs-root/usr/share/lyrah/efi-binaries/ 2>/dev/null || echo "  (none saved!)"

          # Post-install scripts for Calamares shellprocess
          sudo mkdir -p squashfs-root/usr/share/lyrah/installer
          sudo cp installer/scripts/post-install.sh squashfs-root/usr/share/lyrah/installer/
          sudo cp installer/scripts/configure-session.sh squashfs-root/usr/share/lyrah/installer/
          sudo cp installer/scripts/setup-kernel.sh squashfs-root/usr/share/lyrah/installer/
          sudo cp installer/scripts/install-bootloader.sh squashfs-root/usr/share/lyrah/installer/
          sudo chmod +x squashfs-root/usr/share/lyrah/installer/*.sh

          # Wine env config + GPU detection for hybrid laptops
          sudo mkdir -p squashfs-root/etc/profile.d
          sudo cp configs/common/lyrah-wine.sh squashfs-root/etc/profile.d/
          sudo cp configs/common/lyrah-gpu-env.sh squashfs-root/etc/profile.d/

          # Brave browser: enable GPU acceleration and Wayland native rendering.
          # Without these flags Brave falls back to software rendering (CPU)
          # causing page load lag/freezes. Brave reads ~/.config/brave-flags.conf
          # on startup; placing it in /etc/skel gives every new user the defaults.
          sudo mkdir -p squashfs-root/etc/skel/.config
          sudo cp configs/common/brave-flags.conf squashfs-root/etc/skel/.config/brave-flags.conf

          # Logrotate
          sudo mkdir -p squashfs-root/etc/logrotate.d
          sudo cp logging/logrotate-lyrah.conf squashfs-root/etc/logrotate.d/lyrah

          # Live session: Desktop shortcut to launch installer if user
          # switches to the Plasma session from SDDM
          sudo mkdir -p squashfs-root/etc/skel/Desktop
          sudo cp installer/install-lyrah.desktop squashfs-root/etc/skel/Desktop/
          sudo chmod +x squashfs-root/etc/skel/Desktop/install-lyrah.desktop

      # FIX #9: Mount virtual filesystems before chroot
      - name: Customize the system
        run: |
          echo "Customizing Lyrah OS..."
          cat > customize.sh << 'CUSTOMIZE_EOF'
          #!/usr/bin/bash
          set -e
          echo "=== Lyrah OS Customization Script ==="

          # Calamares is already installed via dnf --installroot (build step).
          # No need to run dnf inside the chroot — avoids memory pressure.

          # Base system configuration for --installroot rootfs
          echo "LANG=en_US.UTF-8" > /etc/locale.conf
          ln -sf /usr/share/zoneinfo/UTC /etc/localtime
          echo "lyrahos" > /etc/hostname

          # Update system name
          echo "Lyrah OS" > /etc/fedora-release
          echo "Lyrah OS" > /etc/redhat-release
          echo "Lyrah OS" > /etc/system-release

          # Brand /etc/os-release so KDE Plasma, neofetch, and other tools
          # show "Lyrah OS" instead of "Fedora Linux".  Keep ID_LIKE=fedora
          # so dnf repos and Fedora-specific packages continue to work.
          if [ -f /etc/os-release ]; then
            sed -i 's/^NAME=.*/NAME="Lyrah OS"/' /etc/os-release
            sed -i 's/^PRETTY_NAME=.*/PRETTY_NAME="Lyrah OS"/' /etc/os-release
            sed -i '/^ID_LIKE=/!s/^ID=.*/ID=lyrahos/' /etc/os-release
            if grep -q '^ID_LIKE=' /etc/os-release; then
              sed -i 's/^ID_LIKE=.*/ID_LIKE=fedora/' /etc/os-release
            else
              echo 'ID_LIKE=fedora' >> /etc/os-release
            fi
            sed -i 's|^HOME_URL=.*|HOME_URL="https://github.com/lyrahos/lyrahos"|' /etc/os-release
            sed -i 's|^BUG_REPORT_URL=.*|BUG_REPORT_URL="https://github.com/lyrahos/lyrahos/issues"|' /etc/os-release
          fi

          # Create version file
          mkdir -p /etc
          cat > /etc/lyrah-release << RELEASE_EOF
          VERSION=@@VERSION@@
          BRANCH=@@BRANCH@@
          BUILD_DATE=$(date -u +%Y-%m-%d)
          RELEASE_EOF

          mkdir -p /usr/share/lyrah
          cat > /usr/share/lyrah/README << README_EOF
          Lyrah OS
          A Fedora-based gaming distribution.
          Luna Mode: Console-like gaming frontend (gamescope + Luna UI)
          Desktop Mode: Full KDE Plasma 6 desktop
          README_EOF

          # Create live user (passwordless, autologin)
          if ! id liveuser &>/dev/null; then
            # Ensure gamemode group exists (not present in base Fedora KDE image)
            getent group gamemode &>/dev/null || groupadd gamemode
            useradd -m -G wheel,gamemode -s /bin/bash liveuser
            passwd -d liveuser
          fi

          # Passwordless sudo for the live session.
          # Without this, the Calamares autostart (sudo -E calamares) fails
          # silently because there is no terminal to enter a password.
          echo "liveuser ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/liveuser
          chmod 440 /etc/sudoers.d/liveuser

          # Configure SDDM autologin for live session
          mkdir -p /etc/sddm.conf.d
          cat > /etc/sddm.conf.d/live-autologin.conf << SDDM_EOF
          [Autologin]
          User=liveuser
          Session=lyrah-installer
          Relogin=false
          SDDM_EOF

          # Disable screen lock and power management for live session
          mkdir -p /home/liveuser/.config
          cat > /home/liveuser/.config/kscreenlockerrc << LOCK_EOF
          [Daemon]
          Autolock=false
          LockOnResume=false
          LOCK_EOF

          cat > /home/liveuser/.config/powermanagementprofilesrc << POWER_EOF
          [AC][DPMSControl]
          idleTime=0
          [AC][SuspendSession]
          idleTime=0
          suspendType=0
          POWER_EOF

          chown -R liveuser:liveuser /home/liveuser

          # Disable SELinux for the live session.
          # The ISO remastering process (extract + repack) loses SELinux
          # xattrs. Even permissive mode floods the journal with thousands of
          # AVC denials and delays dbus-broker startup (which cascades into
          # slow SDDM/graphical session launch). Disable SELinux entirely for
          # the live session — there's no benefit when all labels are stripped.
          if [ -f /etc/selinux/config ]; then
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
            sed -i 's/SELINUX=permissive/SELINUX=disabled/' /etc/selinux/config
          fi

          # Exclude dracut livenet module — not needed for local ISO boot.
          # This config is inert during live boot (the ISO's own initramfs is
          # used), but benefits the installed system when Calamares writes to
          # disk and regenerates initramfs.
          mkdir -p /etc/dracut.conf.d
          echo 'omit_dracutmodules+=" livenet "' > /etc/dracut.conf.d/lyrah-live.conf

          # Do NOT rebuild initramfs here. The live ISO boots using the
          # initramfs from the base Fedora ISO's boot area (outside the
          # squashfs). Rebuilding dracut inside the squashfs would create a
          # mismatched initramfs that the bootloader never loads, and
          # kernel-install hooks from dnf may have already written conflicting
          # artifacts into /boot.

          # Enable SDDM — systemctl detects chroot and only creates symlinks.
          # Tolerate failure: installroot may not have full systemd paths yet.
          systemctl enable sddm 2>/dev/null || \
            ln -sf /usr/lib/systemd/system/sddm.service /etc/systemd/system/display-manager.service 2>/dev/null || true
          systemctl set-default graphical.target 2>/dev/null || \
            ln -sf /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target 2>/dev/null || true

          # Add Flathub remote so Discover has apps to install.
          # --if-not-exists avoids failure if Fedora's flatpak package
          # already ships the remote.
          flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo 2>/dev/null || true

          # Create log directories
          mkdir -p /var/log/lyrah/{luna-mode,desktop-mode}/{sessions,crashes}

          echo "Lyrah OS configured successfully"
          CUSTOMIZE_EOF

          # Substitute version/branch placeholders
          sed -i "s/@@VERSION@@/${{ steps.variant.outputs.version }}/g" customize.sh
          sed -i "s/@@BRANCH@@/${{ steps.variant.outputs.variant }}/g" customize.sh

          chmod +x customize.sh
          sudo cp customize.sh squashfs-root/

          # Ensure Fedora usr-merge symlinks exist. The 'filesystem' package
          # should create these, but --installroot inside a container may not
          # run all scriptlets. Without /bin -> usr/bin, chroot can't resolve
          # interpreters and fails with "No such file or directory" (exit 127).
          for link in bin sbin lib lib64; do
            if [ ! -e "squashfs-root/$link" ]; then
              sudo ln -sf "usr/$link" "squashfs-root/$link"
              echo "Created missing symlink: /$link -> usr/$link"
            fi
          done

          # Quick sanity check: verify bash exists inside rootfs
          if [ ! -x squashfs-root/usr/bin/bash ]; then
            echo "ERROR: /usr/bin/bash not found in rootfs — dnf install may have failed"
            ls -la squashfs-root/usr/bin/ | head -20
            exit 1
          fi
          echo "Rootfs verified: /usr/bin/bash exists"

          # Mount virtual filesystems for chroot (needed for systemctl/etc).
          # dnf --installroot does not create runtime mountpoints — create them.
          sudo mkdir -p \
            squashfs-root/proc \
            squashfs-root/sys \
            squashfs-root/dev \
            squashfs-root/dev/pts \
            squashfs-root/run
          sudo mount --bind /proc squashfs-root/proc
          sudo mount --bind /sys squashfs-root/sys
          sudo mount --bind /dev squashfs-root/dev
          sudo mount --bind /dev/pts squashfs-root/dev/pts
          sudo mount --bind /run squashfs-root/run || true

          # Provide DNS resolution inside chroot.
          # systemd installs /etc/resolv.conf as a symlink to
          # ../run/systemd/resolve/stub-resolv.conf. After bind-mounting
          # /run above, that symlink resolves to the host's resolv.conf,
          # so cp fails with "same file". Remove the symlink first.
          sudo rm -f squashfs-root/etc/resolv.conf
          sudo cp /etc/resolv.conf squashfs-root/etc/resolv.conf

          echo "Memory before chroot customization:"
          free -h
          echo "---"

          sudo chroot squashfs-root /customize.sh || {
            RC=$?
            echo "=== Chroot customization failed (exit code $RC) ==="
            echo "--- dmesg (last 30 lines) ---"
            sudo dmesg | tail -30 || true
            echo "--- memory ---"
            free -h
            echo "--- cgroup memory ---"
            cat /sys/fs/cgroup/memory.max 2>/dev/null || cat /sys/fs/cgroup/memory/memory.limit_in_bytes 2>/dev/null || true
            cat /sys/fs/cgroup/memory.current 2>/dev/null || cat /sys/fs/cgroup/memory/memory.usage_in_bytes 2>/dev/null || true
            exit $RC
          }

          echo "Memory after chroot customization:"
          free -h

          # Cleanup chroot mounts
          sudo umount squashfs-root/run 2>/dev/null || true
          sudo umount squashfs-root/dev/pts
          sudo umount squashfs-root/dev
          sudo umount squashfs-root/sys
          sudo umount squashfs-root/proc
          sudo rm squashfs-root/customize.sh

      - name: Sync ISO boot kernel with installed modules
        run: |
          set -euo pipefail
          echo "=== Syncing ISO boot kernel with installed kernel modules ==="

          # The base Fedora ISO ships kernel X, but our Phase 2 may have
          # installed kernel Y (if X is no longer in the repos). When the
          # ISO boots with kernel X but modules are for Y, NOTHING works:
          # no vfat (can't mount ESP), no GPU drivers, no network, etc.
          #
          # Fix: replace the ISO's vmlinuz and initramfs with the version
          # that matches the modules we installed.

          # Find vmlinuz in the ISO boot area — Fedora puts it at different
          # paths depending on the variant (BIOS, UEFI-only, etc.)
          ISO_BOOT_VMLINUZ=""
          ISO_BOOT_INITRD=""
          ISO_KVER=""

          echo "Searching for kernel in ISO boot area..."
          for candidate in \
            iso-build/images/pxeboot/vmlinuz \
            iso-build/isolinux/vmlinuz \
            iso-build/boot/vmlinuz \
            iso-build/boot/x86_64/loader/linux; do
            if [ -f "$candidate" ]; then
              ISO_BOOT_VMLINUZ="$candidate"
              # Derive initrd path from vmlinuz location (try initrd.img then initrd)
              CANDIDATE_DIR="$(dirname "$candidate")"
              if [ -f "$CANDIDATE_DIR/initrd.img" ]; then
                ISO_BOOT_INITRD="$CANDIDATE_DIR/initrd.img"
              else
                ISO_BOOT_INITRD="$CANDIDATE_DIR/initrd"
              fi
              ISO_KVER=$(file "$candidate" | grep -oP 'version \K\S+' || true)
              echo "Found ISO kernel at: $candidate (version: ${ISO_KVER:-unknown})"
              break
            fi
          done

          # Also search dynamically
          if [ -z "$ISO_BOOT_VMLINUZ" ]; then
            FOUND=$(find iso-build/ -name "vmlinuz" -type f 2>/dev/null | head -1 || true)
            if [ -n "$FOUND" ]; then
              ISO_BOOT_VMLINUZ="$FOUND"
              ISO_BOOT_INITRD="$(dirname "$FOUND")/initrd.img"
              ISO_KVER=$(file "$FOUND" | grep -oP 'version \K\S+' || true)
              echo "Found ISO kernel at: $FOUND (version: ${ISO_KVER:-unknown})"
            fi
          fi

          # If no kernel found in ISO at all, determine the correct path from
          # the GRUB config (the 'linux'/'linuxefi' directive tells us where GRUB expects it)
          if [ -z "$ISO_BOOT_VMLINUZ" ]; then
            echo "No kernel found in ISO boot area — checking GRUB config..."
            GRUB_LINUX_PATH=""
            for grub_cfg in $(find iso-build/ -name "grub.cfg" -type f 2>/dev/null); do
              echo "  Checking $grub_cfg..."
              # Match linux, linuxefi, or linux16 directives
              # Handle paths like /images/pxeboot/vmlinuz OR ($root)/boot/x86_64/loader/linux
              GRUB_LINUX_PATH=$(grep -oP '^\s*(linux|linuxefi|linux16)\s+(\(\S+\))?(?=/)\K/\S+' "$grub_cfg" | head -1 || true)
              if [ -n "$GRUB_LINUX_PATH" ]; then
                echo "  GRUB config references kernel at: $GRUB_LINUX_PATH"
                ISO_BOOT_VMLINUZ="iso-build${GRUB_LINUX_PATH}"
                # Match corresponding initrd/initrdefi
                GRUB_INITRD_PATH=$(grep -oP '^\s*(initrd|initrdefi|initrd16)\s+(\(\S+\))?(?=/)\K/\S+' "$grub_cfg" | head -1 || true)
                if [ -n "$GRUB_INITRD_PATH" ]; then
                  ISO_BOOT_INITRD="iso-build${GRUB_INITRD_PATH}"
                else
                  ISO_BOOT_INITRD="$(dirname "$ISO_BOOT_VMLINUZ")/initrd"
                fi
                break
              else
                echo "  No linux/linuxefi directive found in $grub_cfg"
                # Debug: show what the grub.cfg actually contains
                grep -i 'linux\|vmlinuz' "$grub_cfg" | head -5 || true
              fi
            done
          fi

          # Last resort: use images/pxeboot/ as the standard Fedora path
          if [ -z "$ISO_BOOT_VMLINUZ" ]; then
            echo "Could not determine kernel path — using default images/pxeboot/"
            ISO_BOOT_VMLINUZ="iso-build/images/pxeboot/vmlinuz"
            ISO_BOOT_INITRD="iso-build/images/pxeboot/initrd.img"
          fi

          echo "Boot kernel path: $ISO_BOOT_VMLINUZ"
          echo "Boot initrd path: $ISO_BOOT_INITRD"

          # Detect the installed kernel version in the squashfs
          INSTALLED_KVER=$(ls squashfs-root/lib/modules/ 2>/dev/null | sort -V | tail -1)
          if [ -z "$INSTALLED_KVER" ]; then
            echo "FATAL: No kernel modules found in squashfs-root/lib/modules/"
            exit 1
          fi
          echo "Installed kernel modules: $INSTALLED_KVER"

          # Check if versions match
          if [ -n "$ISO_KVER" ] && [ "$ISO_KVER" = "$INSTALLED_KVER" ]; then
            echo "Kernel versions match — no sync needed"
          else
            echo "KERNEL VERSION MISMATCH: ISO=${ISO_KVER:-none} vs modules=$INSTALLED_KVER"
            echo "Replacing ISO boot kernel and regenerating initramfs..."

            # Ensure the target directory exists
            sudo mkdir -p "$(dirname "$ISO_BOOT_VMLINUZ")"

            # Step 1: Copy the matching vmlinuz to the ISO boot area
            VMLINUZ_SRC="squashfs-root/lib/modules/$INSTALLED_KVER/vmlinuz"
            if [ -f "$VMLINUZ_SRC" ]; then
              sudo cp "$VMLINUZ_SRC" "$ISO_BOOT_VMLINUZ"
              echo "Copied vmlinuz from $VMLINUZ_SRC"
            else
              # Try alternate location
              VMLINUZ_SRC="squashfs-root/boot/vmlinuz-$INSTALLED_KVER"
              if [ -f "$VMLINUZ_SRC" ]; then
                sudo cp "$VMLINUZ_SRC" "$ISO_BOOT_VMLINUZ"
                echo "Copied vmlinuz from $VMLINUZ_SRC"
              else
                echo "FATAL: vmlinuz not found for kernel $INSTALLED_KVER"
                find squashfs-root/ -name "vmlinuz*" 2>/dev/null || true
                exit 1
              fi
            fi

            # Step 2: Generate a live-boot initramfs with dracut
            # The initramfs must include dmsquash-live (for booting from squashfs)
            # and the kernel modules for the installed version.
            echo "Generating live initramfs for kernel $INSTALLED_KVER..."

            # Mount required filesystems for chroot dracut
            sudo mount --bind /proc squashfs-root/proc
            sudo mount --bind /sys squashfs-root/sys
            sudo mount --bind /dev squashfs-root/dev

            # Run depmod to ensure module dependency DB is current
            sudo chroot squashfs-root depmod "$INSTALLED_KVER" 2>&1 || echo "WARN: depmod failed"

            # Generate live initramfs
            sudo chroot squashfs-root dracut \
              --force \
              --no-hostonly \
              --add "dmsquash-live" \
              --omit "livenet" \
              --kver "$INSTALLED_KVER" \
              /tmp/initramfs-live.img 2>&1

            # Unmount chroot filesystems
            sudo umount squashfs-root/dev 2>/dev/null || true
            sudo umount squashfs-root/sys 2>/dev/null || true
            sudo umount squashfs-root/proc 2>/dev/null || true

            if [ -f squashfs-root/tmp/initramfs-live.img ]; then
              sudo cp squashfs-root/tmp/initramfs-live.img "$ISO_BOOT_INITRD"
              sudo chmod a+r "$ISO_BOOT_INITRD"
              sudo rm -f squashfs-root/tmp/initramfs-live.img
              echo "Generated and installed new live initramfs"
            else
              echo "FATAL: dracut did not produce initramfs-live.img"
              exit 1
            fi

            # Step 3: Apply Plymouth theme to the new initramfs
            # The dracut-generated initramfs includes whatever Plymouth theme
            # is in the squashfs. Verify the Lyrah theme is present.
            echo "Verifying Plymouth theme in new initramfs..."
            WORK_DIR=$(mktemp -d)
            cd "$WORK_DIR"
            initramfs_info=$(file "$GITHUB_WORKSPACE/$ISO_BOOT_INITRD")
            if echo "$initramfs_info" | grep -qi "zstd"; then
              zstd -dc "$GITHUB_WORKSPACE/$ISO_BOOT_INITRD" | cpio -idm --quiet 2>/dev/null || true
            elif echo "$initramfs_info" | grep -qi "gzip"; then
              gunzip -c "$GITHUB_WORKSPACE/$ISO_BOOT_INITRD" | cpio -idm --quiet 2>/dev/null || true
            else
              cpio -idm --quiet < "$GITHUB_WORKSPACE/$ISO_BOOT_INITRD" 2>/dev/null || true
            fi

            if [ -d usr/share/plymouth/themes ]; then
              # Ensure Lyrah theme is present
              if [ ! -d usr/share/plymouth/themes/lyrah ]; then
                echo "Adding Lyrah Plymouth theme to initramfs..."
                mkdir -p usr/share/plymouth/themes/lyrah
                cp -r "${GITHUB_WORKSPACE}/themes/plymouth/lyrah/"* usr/share/plymouth/themes/lyrah/
              fi
              # Set as default theme
              mkdir -p etc/plymouth
              echo -e "[Daemon]\nTheme=lyrah" > etc/plymouth/plymouthd.conf
              # Remove Fedora themes
              rm -rf usr/share/plymouth/themes/fedora* usr/share/plymouth/themes/spinner 2>/dev/null || true

              # Repack with same compression dracut used
              echo "Repacking initramfs with Plymouth theme..."
              if echo "$initramfs_info" | grep -qi "zstd"; then
                find . -print0 | cpio -0 -o -H newc --quiet 2>/dev/null | zstd -19 -T0 > "${WORK_DIR}/initramfs.new"
              else
                find . -print0 | cpio -0 -o -H newc --quiet 2>/dev/null | gzip -9 > "${WORK_DIR}/initramfs.new"
              fi
              sudo cp "${WORK_DIR}/initramfs.new" "$GITHUB_WORKSPACE/$ISO_BOOT_INITRD"
              echo "Plymouth theme applied to initramfs"
            fi
            cd "$GITHUB_WORKSPACE"
            rm -rf "$WORK_DIR"

            # Verify the new boot kernel
            NEW_KVER=$(file "$ISO_BOOT_VMLINUZ" | grep -oP 'version \K\S+' || true)
            echo "New ISO boot kernel: $NEW_KVER"
            echo "Initramfs size: $(du -sh "$ISO_BOOT_INITRD" | cut -f1)"
          fi

          echo "=== Boot kernel sync complete ==="

      - name: Repack rootfs into SquashFS
        run: |
          echo "Repacking rootfs into SquashFS..."
          echo "Disk before repack:"
          df -h /

          SQUASHFS_PATH="iso-build/LiveOS/squashfs.img"
          sudo mkdir -p iso-build/LiveOS

          # Create SquashFS directly from squashfs-root/ directory.
          # mksquashfs reads and compresses in streaming fashion - no intermediate copy needed.
          # Use zstd instead of xz: ~10x faster decompression with comparable ratio.
          # The entire OS runs from this SquashFS — xz's slow decompression caused
          # visible lag on every library/driver load (mouse stuttering, UI delays).
          sudo mksquashfs squashfs-root "$SQUASHFS_PATH.new" -comp zstd -Xcompression-level 15 -b 256K -xattrs

          # Clean up extracted rootfs and replace old image
          sudo rm -rf squashfs-root
          sudo rm -f "$SQUASHFS_PATH"
          sudo mv "$SQUASHFS_PATH.new" "$SQUASHFS_PATH"

          echo "Repacked SquashFS: $(ls -lh "$SQUASHFS_PATH")"
          echo "Disk after repack:"
          df -h /

      - name: Update ISO metadata
        run: |
          # Fix permissions on iso-build (EFI directory may be restrictive)
          sudo chmod -R a+rX iso-build/

          # Replace shim with GRUB as the default EFI bootloader.
          # Fedora ships BOOTX64.EFI as shim (Secure Boot first-stage loader).
          # On live USB boot, shim detects the device isn't in NVRAM and shows
          # a blue "Boot Option Restoration" screen every time. This is
          # disruptive for a live USB experience.
          # Bypass shim entirely: copy grubx64.efi over BOOTX64.EFI so UEFI
          # firmware loads GRUB directly. Secure Boot won't work, but live
          # USBs don't need it — the installed system still uses shim via
          # Calamares's grub2-install.
          if [ -f iso-build/EFI/BOOT/grubx64.efi ]; then
            echo "Replacing shim with GRUB as default EFI bootloader (removes Boot Option Restoration screen)"
            sudo cp -f iso-build/EFI/BOOT/grubx64.efi iso-build/EFI/BOOT/BOOTX64.EFI
          fi
          if [ -f iso-build/.discinfo ]; then
            sudo sed -i "s/Fedora/Lyrah OS/g" iso-build/.discinfo
          fi
          find iso-build -name "isolinux.cfg" -o -name "grub.cfg" | while read cfg; do
            # CRITICAL: Fix ALL volume label references to match the ISO
            # volume label set by xorriso (-V "LyrahOS").
            #
            # Fedora's grub.cfg uses the label in THREE different patterns:
            #   1. CDLABEL=Fedora-KDE-Live-43-1-6  (kernel command line)
            #   2. search --set=root -l 'Fedora-KDE-Live-43-1-6'  (find ISO)
            #   3. set isolabel="Fedora-KDE-Live-43-1-6"  (variable)
            #
            # Pattern 2 is what GRUB uses to locate the ISO filesystem for
            # loading the kernel and initrd. If it doesn't match, GRUB can't
            # find the kernel → black screen. Pattern 1 is what dracut uses
            # to find the live squashfs at runtime. If it doesn't match,
            # dracut can't mount the root → underscore "_" on black screen.
            #
            # All three MUST be replaced BEFORE the cosmetic "Fedora → Lyrah OS"
            # rename, otherwise the label gets a space ("Lyrah OS-KDE-...")
            # which doesn't match "LyrahOS".
            sudo sed -i -E 's/CDLABEL=[^ "]+/CDLABEL=LyrahOS/g' "$cfg" || true
            sudo sed -i -E "s/search ([^']*)-l '[^']*'/search \1-l 'LyrahOS'/g" "$cfg" || true
            sudo sed -i -E 's/set isolabel="[^"]*"/set isolabel="LyrahOS"/g' "$cfg" || true
            # Disable SELinux from the kernel command line. The config-file
            # change above only takes effect after init; selinux=0 disables
            # it immediately so no AVC denials are generated at all.
            # Also add rd.live.dir=/LiveOS so dracut explicitly knows where
            # the squashfs lives — prevents mismatches when the rootfs is
            # built from scratch rather than extracted from the original ISO.
            # Add Plymouth splash parameters for smooth boot experience.
            # nomodeset: Disable hardware GPU drivers for the live session.
            # This forces software rendering (llvmpipe) which works on ALL
            # hardware. Without it, kwin_wayland fails to initialize on GPUs
            # with poor open-source driver support (notably newer NVIDIA with
            # nouveau). The installed system does NOT inherit nomodeset — after
            # Calamares writes to disk, the system boots with full GPU accel.
            # UEFI GOP sets native resolution before the kernel, so the
            # installer still displays at the monitor's native resolution.
            sudo sed -i -E 's/(rd\.live\.image)/\1 rd.live.dir=\/LiveOS selinux=0 nomodeset splash plymouth.enable=1/' "$cfg" || true
            # Cosmetic: replace entire menuentry titles with clean Lyrah OS names.
            # The naive "s/Fedora/Lyrah OS/g" turns "Start Fedora-KDE-Desktop-Live-43-1.6"
            # into "Start Lyrah OS-KDE-Desktop-Live-43-1.6" — ugly. Instead, replace
            # the entire title strings with clean names.
            # Order matters: specific patterns before generic to prevent early matching.
            sudo sed -i -E "s/menuentry 'Start [^']*basic graphics[^']*'/menuentry 'Start Lyrah OS in basic graphics mode'/g" "$cfg" || true
            sudo sed -i -E "s/menuentry 'Test this media[^']*'/menuentry 'Test this media \& start Lyrah OS'/g" "$cfg" || true
            sudo sed -i -E "s/menuentry 'Start Fedora[^']*'/menuentry 'Start Lyrah OS'/g" "$cfg" || true
            # Catch any remaining "Fedora" references (variables, comments, etc.)
            sudo sed -i "s/Fedora/Lyrah OS/g" "$cfg" || true
          done

          # Skip the boot menu entirely — boot straight into the live
          # session / installer instead of showing the Fedora "press any
          # key" splash with KDE desktop / media testing options.
          # ISOLINUX (BIOS boot): set timeout to 1 decisecond (instant),
          # disable the "press any key" prompt, default to first entry.
          # Note: isolinux keywords are case-insensitive; Fedora uses
          # uppercase (TIMEOUT, PROMPT). The sed I flag handles both.
          find iso-build -name "isolinux.cfg" | while read cfg; do
            sudo sed -i 's/^[Tt][Ii][Mm][Ee][Oo][Uu][Tt] .*/timeout 1/' "$cfg" || true
            sudo sed -i 's/^[Tt][Oo][Tt][Aa][Ll][Tt][Ii][Mm][Ee][Oo][Uu][Tt] .*/totaltimeout 1/' "$cfg" || true
            if grep -qi '^prompt ' "$cfg" 2>/dev/null; then
              sudo sed -i 's/^[Pp][Rr][Oo][Mm][Pp][Tt] .*/prompt 0/' "$cfg" || true
            else
              echo "prompt 0" | sudo tee -a "$cfg" > /dev/null
            fi
          done
          # GRUB (UEFI boot): force immediate boot into the first entry and
          # suppress interactive prompts/menu flashes as much as possible.
          find iso-build -name "grub.cfg" | while read cfg; do
            sudo sed -i -E 's/^(\s*)set timeout=.*/\1set timeout=0/' "$cfg" || true
            sudo sed -i -E 's/^(\s*)set default=.*/\1set default=0/' "$cfg" || true
            # Hide the menu entirely (prevents brief flash before timeout)
            if grep -q 'set timeout_style=' "$cfg" 2>/dev/null; then
              sudo sed -i -E 's/set timeout_style=.*/set timeout_style=hidden/' "$cfg" || true
            else
              sudo sed -i -E '/^set timeout=0/a set timeout_style=hidden' "$cfg" || true
            fi
            # Some Fedora EFI configs include an interruptible sleep with
            # "Press any key ... system reset" messaging before GRUB menu.
            # Force that path to be non-blocking.
            sudo sed -i -E '/system reset/I d' "$cfg" || true
            sudo sed -i -E 's/sleep --interruptible [0-9]+/sleep 0/g' "$cfg" || true
            sudo sed -i -E 's/sleep -i [0-9]+/sleep 0/g' "$cfg" || true
            # Force console terminal mode instead of gfxterm to minimize
            # blue screen flash during GRUB → kernel transition.
            if ! grep -q 'terminal_output console' "$cfg" 2>/dev/null; then
              sudo sed -i -E '/^set timeout=0/i terminal_output console' "$cfg" || true
            fi
          done

      - name: Create new ISO
        run: |
          echo "Creating Lyrah OS ISO..."
          mkdir -p output
          ISO_NAME="Lyrah-OS-${{ steps.variant.outputs.version }}-${{ steps.variant.outputs.variant }}-x86_64.iso"

          # Create a hybrid ISO bootable from both CD-ROM and USB (dd/Etcher/Rufus).
          #
          # The "appended partition" method (used by Debian, Arch, Ubuntu)
          # physically places the EFI boot image as a separate GPT partition
          # AFTER the ISO 9660 data. This is critical for USB compatibility:
          #
          #   - The old approach embedded efiboot.img inside the ISO filesystem
          #     and used -isohybrid-gpt-basdat to create a "virtual" GPT entry
          #     pointing into the ISO data. Many UEFI firmwares and USB-writing
          #     tools (Etcher, dd) cannot find this virtual partition — Etcher
          #     shows "no map" and UEFI firmware drops to shell.
          #
          #   - The appended partition method creates a REAL, physically separate
          #     GPT partition that every UEFI firmware can discover. After dd to
          #     USB, the drive has: [MBR] [ISO9660 data] [EFI System Partition]
          #     with proper MBR and GPT partition tables.
          #
          # Key xorriso flags:
          #   -isohybrid-mbr      Embed MBR boot code (from isohdpfx.bin) so BIOS
          #                       firmware can boot after raw dd write
          #   -partition_offset 16 Shift ISO data by 16 sectors (32KB) to leave
          #                       room for GPT header and partition entries
          #   -append_partition 2  Append efiboot.img as GPT partition 2 with
          #                       EFI System Partition type GUID
          #   --interval:appended_partition_2  Tell El Torito to reference the
          #                       appended partition for EFI boot catalog entry
          #   -isohybrid-gpt-basdat  Create GPT entry for partition 1 (ISO data)

          ISOHDPFX="/usr/lib/ISOLINUX/isohdpfx.bin"

          # Search for efiboot.img at all common Fedora paths.
          # Fedora 43+ may place it in different locations depending on
          # whether the ISO is UEFI-only or dual-boot.
          EFI_IMG=""
          for efi_path in \
            iso-build/images/efiboot.img \
            iso-build/boot/images/efiboot.img \
            iso-build/EFI/BOOT/efiboot.img \
            iso-build/images/macboot.img \
          ; do
            if [ -f "$efi_path" ]; then
              cp "$efi_path" efiboot.img
              EFI_IMG="efiboot.img"
              echo "Found EFI boot image at $efi_path ($(ls -lh efiboot.img | awk '{print $5}'))"
              break
            fi
          done

          # If no standalone efiboot.img, try to extract one from the EFI
          # directory. Fedora 43 UEFI-only ISOs may not ship a separate
          # efiboot.img file — instead the EFI binaries live directly in
          # the ISO's /EFI/BOOT/ directory. In that case, create an
          # efiboot.img (FAT12/16 image) from those EFI binaries.
          if [ -z "$EFI_IMG" ] && [ -d iso-build/EFI ]; then
            echo "No efiboot.img found — creating one from EFI directory..."
            # Calculate size needed (EFI dir + padding)
            EFI_SIZE_KB=$(du -skL iso-build/EFI | cut -f1)
            # Add 512KB padding for FAT overhead, round up to nearest 1MB
            IMG_SIZE_KB=$(( (EFI_SIZE_KB + 512 + 1023) / 1024 * 1024 ))
            [ "$IMG_SIZE_KB" -lt 4096 ] && IMG_SIZE_KB=4096
            echo "Creating ${IMG_SIZE_KB}KB FAT image for EFI boot..."
            dd if=/dev/zero of=efiboot.img bs=1K count="$IMG_SIZE_KB" 2>/dev/null
            mkfs.vfat efiboot.img
            MOUNT_DIR=$(mktemp -d)
            sudo mount -o loop efiboot.img "$MOUNT_DIR"
            # Fedora's EFI directory often has symlinks where e.g.
            # bootx64.efi -> shimx64.efi. The FAT filesystem is
            # case-insensitive, so BOOTX64.EFI and bootx64.efi collide.
            # Dereference symlinks (-L) and skip files that already exist
            # on the case-insensitive FAT target (--no-clobber).
            sudo cp -rL --no-clobber iso-build/EFI "$MOUNT_DIR/" 2>/dev/null || true
            echo "EFI image contents:"
            ls -laR "$MOUNT_DIR/EFI/" 2>/dev/null || true
            sudo umount "$MOUNT_DIR"
            rmdir "$MOUNT_DIR"
            EFI_IMG="efiboot.img"
            echo "Created efiboot.img ($(ls -lh efiboot.img | awk '{print $5}'))"
          fi

          if [ -z "$EFI_IMG" ]; then
            echo "FATAL: No EFI boot image found and no EFI directory to create one from"
            echo "Contents of iso-build/:"
            find iso-build/ -maxdepth 3 -type f | head -50
            exit 1
          fi

          XORRISO_ARGS=(
            -o "output/$ISO_NAME"
            -V "LyrahOS"
            -J -joliet-long -r
            -partition_offset 16
          )

          # BIOS + UEFI hybrid: isolinux available (older Fedora / dual-boot ISOs)
          # -isohybrid-mbr embeds MBR boot code from isohdpfx.bin for BIOS USB boot.
          # It REQUIRES an isolinux El Torito entry to patch — cannot be used alone.
          if [ -f iso-build/isolinux/isolinux.bin ] && [ -f "$ISOHDPFX" ]; then
            echo "Found isolinux — enabling BIOS + UEFI hybrid boot"
            XORRISO_ARGS+=(
              -isohybrid-mbr "$ISOHDPFX"
              -b isolinux/isolinux.bin
              -c isolinux/boot.cat
              -no-emul-boot
              -boot-load-size 4
              -boot-info-table
              -eltorito-alt-boot
            )
          else
            # UEFI-only hybrid: no isolinux (Fedora 43+ KDE)
            # --mbr-force-bootable creates a minimal MBR with the bootable flag
            # set, without needing isohdpfx.bin or isolinux. This gives USB
            # tools (Etcher, Rufus) a valid MBR to recognize.
            echo "No isolinux — enabling UEFI-only hybrid boot"
            XORRISO_ARGS+=(--mbr-force-bootable)
          fi

          # Append EFI System Partition as a real GPT partition after the ISO data.
          XORRISO_ARGS+=(
            -e --interval:appended_partition_2:all::
            -no-emul-boot
            -isohybrid-gpt-basdat
            -append_partition 2 C12A7328-F81F-11D2-BA4B-00A0C93EC93B "$EFI_IMG"
            -appended_part_as_gpt
          )

          XORRISO_ARGS+=(iso-build/)

          echo "Running xorriso with args: ${XORRISO_ARGS[*]}"
          sudo xorriso -as mkisofs "${XORRISO_ARGS[@]}"

          # === Partition table diagnostics ===
          # These help verify the hybrid ISO is correct and diagnose boot issues.
          echo ""
          echo "=== ISO Partition Table Diagnostics ==="
          ISO_PATH="output/$ISO_NAME"

          echo "--- File identification ---"
          file "$ISO_PATH"

          echo "--- MBR partition table (fdisk) ---"
          fdisk -l "$ISO_PATH" 2>&1 || true

          echo "--- MBR boot signature ---"
          MBR_SIG=$(xxd -s 510 -l 2 -p "$ISO_PATH")
          if [ "$MBR_SIG" = "55aa" ]; then
            echo "PASS: MBR signature 0x55AA present (BIOS bootable)"
          else
            echo "FAIL: MBR signature is 0x${MBR_SIG} (expected 55aa)"
          fi

          echo "--- MBR partition type check ---"
          # Byte 450 is the partition type of MBR entry 1 (0x00=empty, 0x17=hidden NTFS/ISOhybrid, 0xEF=EFI)
          MBR_TYPE=$(xxd -s 450 -l 1 -p "$ISO_PATH")
          echo "MBR partition 1 type: 0x${MBR_TYPE}"

          echo "--- GPT header check ---"
          # GPT signature "EFI PART" at LBA 1 (offset 512)
          GPT_SIG=$(xxd -s 512 -l 8 -p "$ISO_PATH")
          if [ "$GPT_SIG" = "4546492050415254" ]; then
            echo "PASS: GPT header found (UEFI bootable)"
          else
            echo "INFO: No GPT header at LBA 1 (offset 512) — sig: $GPT_SIG"
            # With -partition_offset 16, GPT may be at sector 1 relative to
            # the partition offset. Check at 16*2048 + 512.
            ALT_OFFSET=$((16 * 2048 + 512))
            ALT_SIG=$(xxd -s $ALT_OFFSET -l 8 -p "$ISO_PATH" 2>/dev/null || echo "")
            if [ "$ALT_SIG" = "4546492050415254" ]; then
              echo "PASS: GPT header found at offset $ALT_OFFSET (with partition_offset)"
            fi
          fi

          echo "=== End Diagnostics ==="
          ls -lh output/

      - name: Verify ISO was created
        run: |
          ISO_FILE="output/Lyrah-OS-${{ steps.variant.outputs.version }}-${{ steps.variant.outputs.variant }}-x86_64.iso"
          if [ ! -f "$ISO_FILE" ]; then
            echo "ERROR: ISO file was not created!"
            exit 1
          fi
          echo "ISO created successfully:"
          ls -lh "$ISO_FILE"
          SIZE_MB=$(du -m "$ISO_FILE" | cut -f1)
          echo "ISO size: ${SIZE_MB}MB"
          if [ $SIZE_MB -lt 100 ]; then
            echo "WARNING: ISO seems too small!"
          fi

      - name: Generate checksums
        run: |
          cd output/
          sha256sum *.iso > SHA256SUMS
          sha512sum *.iso > SHA512SUMS
          cat SHA256SUMS

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lyrah-os-${{ steps.variant.outputs.variant }}-${{ steps.variant.outputs.version }}
          path: |
            output/*.iso
            output/SHA256SUMS
            output/SHA512SUMS
          retention-days: 30

      - name: Upload to release (if tag)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            output/*.iso
            output/SHA256SUMS
            output/SHA512SUMS
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-iso:
    needs: build-iso
    runs-on: ubuntu-latest

    steps:
      - name: Download ISO
        uses: actions/download-artifact@v4
        with:
          pattern: lyrah-os-*
          merge-multiple: true

      - name: Install QEMU and OVMF
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils ovmf

      # Test 1: CD-ROM boot (BIOS) — original test, verifies isolinux path
      - name: Test BIOS CD-ROM boot
        run: |
          ISO_FILE=$(ls *.iso | head -1)
          echo "Testing BIOS CD-ROM boot: $ISO_FILE"
          touch bios-cdrom.log
          timeout 90s qemu-system-x86_64 \
            -m 2048 \
            -smp 2 \
            -cdrom "$ISO_FILE" \
            -boot d \
            -display none \
            -serial file:bios-cdrom.log \
            2>&1 &
          QEMU_PID=$!
          sleep 60
          if ps -p $QEMU_PID > /dev/null 2>&1; then
            echo "PASS: BIOS CD-ROM boot — QEMU still running after 60s"
            kill $QEMU_PID 2>/dev/null || true
          else
            echo "WARN: BIOS CD-ROM boot — QEMU exited early"
            cat bios-cdrom.log 2>/dev/null || true
          fi

      # Test 2: USB-style boot (BIOS) — simulates dd/Etcher write by
      # booting the raw ISO as a hard drive. This is what fails when
      # the hybrid MBR is missing or malformed.
      - name: Test BIOS USB boot (raw drive)
        run: |
          ISO_FILE=$(ls *.iso | head -1)
          echo "Testing BIOS USB boot (raw drive): $ISO_FILE"
          touch bios-usb.log
          timeout 90s qemu-system-x86_64 \
            -m 2048 \
            -smp 2 \
            -drive file="$ISO_FILE",format=raw,if=virtio,readonly=on \
            -display none \
            -serial file:bios-usb.log \
            2>&1 &
          QEMU_PID=$!
          sleep 60
          if ps -p $QEMU_PID > /dev/null 2>&1; then
            echo "PASS: BIOS USB boot — QEMU still running after 60s"
            kill $QEMU_PID 2>/dev/null || true
          else
            echo "WARN: BIOS USB boot — QEMU exited early"
            cat bios-usb.log 2>/dev/null || true
          fi

      # Test 3: UEFI boot — uses OVMF firmware to test the EFI boot path.
      # This verifies that the appended EFI System Partition is correctly
      # structured and GRUB can load from it.
      - name: Test UEFI boot
        run: |
          ISO_FILE=$(ls *.iso | head -1)
          echo "Testing UEFI boot: $ISO_FILE"

          # Find OVMF firmware (path varies by distro/version)
          OVMF=""
          for path in /usr/share/OVMF/OVMF_CODE.fd /usr/share/OVMF/OVMF_CODE_4M.fd /usr/share/ovmf/OVMF.fd; do
            if [ -f "$path" ]; then
              OVMF="$path"
              break
            fi
          done
          if [ -z "$OVMF" ]; then
            echo "SKIP: OVMF firmware not found"
            exit 0
          fi
          echo "Using OVMF: $OVMF"

          # Create a writable copy of OVMF vars (QEMU requires rw access)
          OVMF_VARS=""
          for vpath in /usr/share/OVMF/OVMF_VARS.fd /usr/share/OVMF/OVMF_VARS_4M.fd; do
            if [ -f "$vpath" ]; then
              cp "$vpath" /tmp/ovmf_vars.fd
              OVMF_VARS=/tmp/ovmf_vars.fd
              break
            fi
          done

          touch uefi.log
          QEMU_UEFI_ARGS=(
            -m 2048 -smp 2
            -drive if=pflash,format=raw,readonly=on,file="$OVMF"
          )
          if [ -n "$OVMF_VARS" ]; then
            QEMU_UEFI_ARGS+=(-drive if=pflash,format=raw,file="$OVMF_VARS")
          fi
          QEMU_UEFI_ARGS+=(
            -drive file="$ISO_FILE",format=raw,if=virtio,readonly=on
            -display none
            -serial file:uefi.log
          )

          timeout 90s qemu-system-x86_64 "${QEMU_UEFI_ARGS[@]}" 2>&1 &
          QEMU_PID=$!
          sleep 60
          if ps -p $QEMU_PID > /dev/null 2>&1; then
            echo "PASS: UEFI boot — QEMU still running after 60s"
            kill $QEMU_PID 2>/dev/null || true
          else
            echo "WARN: UEFI boot — QEMU exited early"
            cat uefi.log 2>/dev/null || true
          fi
