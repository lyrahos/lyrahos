name: Build Lyrah OS ISO

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - testing
          - dev

env:
  FEDORA_VERSION: 43
  BASE_ISO_URL: https://download.fedoraproject.org/pub/fedora/linux/releases/43/KDE/x86_64/iso/Fedora-KDE-Desktop-Live-43-1.6.x86_64.iso

jobs:
  build-iso:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          sudo rm -rf /usr/share/swift /usr/share/miniconda /usr/share/az_* /opt/hostedtoolcache
          sudo docker image prune -af 2>/dev/null || true
          echo "Available disk space:"
          sudo df -h /

      - name: Determine build variant
        id: variant
        run: |
          BRANCH="${{ github.ref_name }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH="${{ inputs.branch }}"
          fi

          case $BRANCH in
            main)
              echo "variant=main" >> $GITHUB_OUTPUT
              echo "version=1.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
            testing)
              echo "variant=testing" >> $GITHUB_OUTPUT
              echo "version=1.0-beta.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "variant=dev" >> $GITHUB_OUTPUT
              echo "version=1.0-dev.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            genisoimage \
            xorriso \
            squashfs-tools \
            wget \
            rsync

      - name: Download base Fedora KDE ISO
        run: |
          echo "Downloading Fedora KDE Live ISO..."
          wget -O fedora-base.iso "${{ env.BASE_ISO_URL }}"
          ls -lh fedora-base.iso

      - name: Extract ISO contents
        id: extract-iso
        run: |
          echo "Extracting ISO..."
          mkdir -p iso-extract iso-build
          sudo mount -o loop fedora-base.iso iso-extract
          sudo rsync -av iso-extract/ iso-build/
          sudo umount iso-extract
          sudo chmod -R u+w iso-build/
          # Free disk: remove base ISO now that contents are extracted
          rm -f fedora-base.iso
          # Remove the squashfs/rootfs image — we build rootfs from scratch
          # with dnf --installroot instead of extracting from EROFS/SquashFS.
          # Only the boot infrastructure (EFI, grub, isolinux) is kept.
          sudo rm -f iso-build/LiveOS/squashfs.img iso-build/LiveOS/rootfs.img 2>/dev/null || true
          echo "Disk after ISO extraction (rootfs images removed):"
          df -h /

          # Detect kernel version from ISO boot area.
          # Phase 2 must install this EXACT version so modules match the
          # vmlinuz that GRUB actually boots. A mismatch means no runtime
          # module loading (no GPU drivers, no network, no sound).
          ISO_KVER=""
          for vmlinuz_path in iso-build/images/pxeboot/vmlinuz iso-build/isolinux/vmlinuz; do
            if [ -f "$vmlinuz_path" ]; then
              ISO_KVER=$(file "$vmlinuz_path" | grep -oP 'version \K\S+' || true)
              if [ -n "$ISO_KVER" ]; then
                echo "Detected ISO boot kernel: $ISO_KVER"
                break
              fi
            fi
          done
          if [ -z "$ISO_KVER" ]; then
            echo "WARNING: Could not detect ISO kernel version — phase 2 will install latest"
          fi
          echo "iso_kver=${ISO_KVER}" >> $GITHUB_OUTPUT

      # Swap must be expanded BEFORE rootfs build — the default runner swap
      # (3GB) is not enough for dnf dependency resolution of large package sets.
      - name: Ensure adequate swap space
        run: |
          CURRENT_SWAP_KB=$(swapon --show=SIZE --bytes --noheadings 2>/dev/null | awk '{s+=$1} END{print int(s/1024)}')
          echo "Current swap: ${CURRENT_SWAP_KB:-0} KB"
          NEED_KB=$((8 * 1024 * 1024))
          if [ "${CURRENT_SWAP_KB:-0}" -lt "$NEED_KB" ]; then
            echo "Expanding swap to 8GB..."
            sudo swapoff -a 2>/dev/null || true
            sudo rm -f /swapfile /mnt/swapfile
            sudo fallocate -l 8G /mnt/swapfile
            sudo chmod 600 /mnt/swapfile
            sudo mkswap /mnt/swapfile
            sudo swapon /mnt/swapfile
          else
            echo "Existing swap is sufficient"
          fi
          free -h

      # Cache the dnf-built rootfs to skip the slow package download + install
      # on subsequent builds. Key changes when workflow (package list) changes.
      - name: Restore rootfs cache
        id: rootfs-cache
        uses: actions/cache@v4
        with:
          path: rootfs-cache.tar
          key: rootfs-v5-dnf-${{ hashFiles('.github/workflows/build-iso.yml') }}-${{ env.FEDORA_VERSION }}

      - name: Extract rootfs from cache
        if: steps.rootfs-cache.outputs.cache-hit == 'true'
        run: |
          echo "Rootfs cache hit — extracting from tar archive..."
          sudo mkdir -p squashfs-root
          sudo tar --xattrs --xattrs-include='*' -xpf rootfs-cache.tar -C squashfs-root
          echo "Rootfs restored with preserved permissions, ownership, and xattrs"
          echo "Root entries:"
          ls squashfs-root/ | head -20
          echo "Rootfs size: $(du -sh squashfs-root/ | cut -f1)"

      # Build rootfs from scratch using dnf --installroot instead of
      # extracting from the Fedora ISO's EROFS/SquashFS image.
      #
      # The old approach mounted the EROFS image, which triggered OOM:
      # the kernel EROFS driver allocates non-swappable slab memory for
      # BIG_PCLUSTER decompression, exceeding the runner's cgroup limit.
      #
      # dnf --installroot avoids this entirely — it downloads and installs
      # packages in userspace with normal swappable memory.
      #
      # Phase 1: Install everything EXCEPT kernel* to keep peak memory low.
      # Phase 2: Install kernel in a separate pass after phase 1 memory is freed.
      - name: Build rootfs (phase 1 - base system, no kernel)
        if: steps.rootfs-cache.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          echo "Building rootfs from scratch using dnf --installroot..."
          echo "Phase 1: base system (excluding kernel* to avoid OOM)"
          sudo mkdir -p squashfs-root

          echo "=== Memory before phase 1 ==="
          free -h
          echo "==="

          # Use a Fedora container to run dnf --installroot.
          # The container provides Fedora repo configs; --installroot creates
          # a fresh Fedora root filesystem at the mounted /rootfs path.
          # Excluding kernel* drastically reduces peak memory — the kernel
          # package tree is the single largest contributor to dnf metadata bloat.
          # --use-host-config is REQUIRED for dnf5 (Fedora 41+).
          # Without it, dnf5 looks for repos inside the empty installroot
          # and resolves nothing. This flag tells it to use the container's
          # /etc/yum.repos.d/ and /etc/dnf/dnf.conf instead.
          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c '
              set -euo pipefail

              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                --exclude=kernel* \
                --exclude=virtualbox-guest-additions* \
                filesystem \
                setup \
                @kde-desktop-environment \
                NetworkManager \
                pipewire \
                wireplumber \
                sddm \
                gamemode \
                mangohud \
                grub2-efi-x64 \
                plymouth \
                dracut \
                systemd \
                dnf \
                passwd \
                sudo \
                bash \
                glibc-langpack-en \
                util-linux

              # Calamares: install separately so a repo issue does not
              # take down the entire base system install.
              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                calamares calamares-libs || \
                echo "WARN: Calamares install failed — may need custom repo"

              dnf clean all --installroot=/rootfs

              # Verify install actually wrote files
              if [ ! -x /rootfs/usr/bin/bash ]; then
                echo "FATAL: /usr/bin/bash missing after dnf install — rootfs is empty"
                ls -la /rootfs/ || true
                exit 1
              fi
              echo "Rootfs verified inside container: /usr/bin/bash exists"
            '

          echo "Phase 1 complete. Rootfs size: $(sudo du -sh squashfs-root/ | cut -f1)"
          echo "Memory after phase 1:"
          free -h
          echo "Disk after phase 1:"
          df -h /

      - name: Install kernel into rootfs (phase 2)
        if: steps.rootfs-cache.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          echo "Phase 2: Installing kernel (separate pass to avoid OOM)..."

          echo "=== Memory before phase 2 ==="
          free -h
          echo "==="

          # Separate container run so phase 1 memory is fully released.
          # Only the kernel package tree is resolved here — much smaller
          # dependency graph than the full system.
          #
          # Use kernel-core + kernel-modules-core instead of the 'kernel'
          # meta-package. The meta-package triggers kernel-install hooks
          # that write to /boot and run grub2-mkconfig — all pointless
          # inside --installroot since boot infrastructure comes from the
          # base Fedora ISO. We only need modules for runtime hardware support.
          #
          # Pin to the ISO's kernel version so modules match the vmlinuz
          # that GRUB actually boots. A version mismatch means modprobe
          # can't find modules at runtime (no GPU, no network, no sound).
          ISO_KVER="${{ steps.extract-iso.outputs.iso_kver }}"
          KERNEL_PKGS="kernel-core kernel-modules-core"
          if [ -n "$ISO_KVER" ]; then
            # file reports: 6.x.y-z.fc43.x86_64 — strip arch suffix for dnf
            KVER_DNF="${ISO_KVER%.x86_64}"
            KVER_DNF="${KVER_DNF%.aarch64}"
            echo "Pinning kernel to ISO version: $KVER_DNF"
            KERNEL_PKGS="kernel-core-${KVER_DNF} kernel-modules-core-${KVER_DNF}"
          else
            echo "WARNING: ISO kernel version unknown — installing latest"
          fi

          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c "
              set -euo pipefail

              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                $KERNEL_PKGS

              dnf clean all --installroot=/rootfs

              # Verify kernel modules were installed
              ls /rootfs/lib/modules/ || {
                echo 'FATAL: No kernel modules found after dnf install'
                exit 1
              }
            "

          echo "Phase 2 complete. Rootfs size: $(sudo du -sh squashfs-root/ | cut -f1)"
          echo "Kernel modules installed:"
          ls squashfs-root/lib/modules/ 2>/dev/null || echo "WARNING: No kernel modules found"
          echo "Memory after phase 2:"
          free -h
          echo "Disk after phase 2:"
          df -h /
          echo "Root entries:"
          ls squashfs-root/ | head -20

      # Archive rootfs as tar to preserve permissions, ownership, xattrs
      # for caching across builds.
      - name: Create rootfs cache archive
        if: steps.rootfs-cache.outputs.cache-hit != 'true'
        run: |
          echo "Creating rootfs tar archive (preserves permissions, xattrs, ownership)..."
          sudo tar --xattrs --xattrs-include='*' -cpf rootfs-cache.tar -C squashfs-root .
          sudo chmod 644 rootfs-cache.tar
          echo "Archive size: $(du -sh rootfs-cache.tar | cut -f1)"

      # Save cache immediately after build so it persists even if later steps fail
      - name: Save rootfs cache
        if: steps.rootfs-cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: rootfs-cache.tar
          key: rootfs-v5-dnf-${{ hashFiles('.github/workflows/build-iso.yml') }}-${{ env.FEDORA_VERSION }}

      # Copy Lyrah OS configs into rootfs before chroot
      - name: Stage Lyrah OS files
        run: |
          echo "Staging Lyrah OS files into rootfs..."

          # Calamares config and branding
          sudo mkdir -p squashfs-root/etc/calamares
          sudo cp -r installer/calamares/settings.conf squashfs-root/etc/calamares/
          sudo cp -r installer/calamares/modules squashfs-root/etc/calamares/
          sudo mkdir -p squashfs-root/usr/share/calamares/branding/lyrah
          sudo cp -r installer/calamares/branding/lyrah/* squashfs-root/usr/share/calamares/branding/lyrah/

          # Session desktop files
          sudo mkdir -p squashfs-root/usr/share/wayland-sessions
          sudo cp configs/luna-mode/luna-mode.desktop squashfs-root/usr/share/wayland-sessions/
          sudo cp configs/desktop-mode/plasma.desktop squashfs-root/usr/share/wayland-sessions/

          # SDDM theme
          sudo mkdir -p squashfs-root/usr/share/sddm/themes/lyrah-space
          sudo cp -r themes/sddm/lyrah-space/* squashfs-root/usr/share/sddm/themes/lyrah-space/

          # SDDM config (lyrah theme as default)
          sudo mkdir -p squashfs-root/etc/sddm.conf.d
          sudo cp configs/common/lyrah.conf squashfs-root/etc/sddm.conf.d/lyrah.conf

          # Plymouth theme
          sudo mkdir -p squashfs-root/usr/share/plymouth/themes/lyrah
          sudo cp -r themes/plymouth/lyrah/* squashfs-root/usr/share/plymouth/themes/lyrah/

          # Scripts
          sudo mkdir -p squashfs-root/usr/share/lyrah/setup
          sudo cp scripts/first-boot.sh squashfs-root/usr/share/lyrah/setup/
          sudo cp scripts/configure-gpu.sh squashfs-root/usr/share/lyrah/setup/
          sudo chmod +x squashfs-root/usr/share/lyrah/setup/*.sh

          sudo mkdir -p squashfs-root/usr/bin
          sudo cp scripts/luna-session squashfs-root/usr/bin/
          sudo cp scripts/lyrah-switch-mode squashfs-root/usr/bin/
          sudo cp scripts/lyrah-configure-autologin squashfs-root/usr/bin/
          sudo cp scripts/lyrah-update squashfs-root/usr/bin/
          sudo cp scripts/lyrah-upload-log squashfs-root/usr/bin/
          sudo cp scripts/lyrah-crash-monitor squashfs-root/usr/bin/
          sudo chmod +x squashfs-root/usr/bin/luna-session squashfs-root/usr/bin/lyrah-*

          # Systemd units
          sudo cp system/*.service system/*.timer squashfs-root/etc/systemd/system/ 2>/dev/null || true

          # Post-install scripts for Calamares shellprocess
          sudo mkdir -p squashfs-root/usr/share/lyrah/installer
          sudo cp installer/scripts/post-install.sh squashfs-root/usr/share/lyrah/installer/
          sudo cp installer/scripts/configure-session.sh squashfs-root/usr/share/lyrah/installer/
          sudo chmod +x squashfs-root/usr/share/lyrah/installer/*.sh

          # Wine env config
          sudo mkdir -p squashfs-root/etc/profile.d
          sudo cp configs/common/lyrah-wine.sh squashfs-root/etc/profile.d/

          # Logrotate
          sudo mkdir -p squashfs-root/etc/logrotate.d
          sudo cp logging/logrotate-lyrah.conf squashfs-root/etc/logrotate.d/lyrah

          # Live session: Calamares autostart for liveuser
          sudo mkdir -p squashfs-root/etc/skel/.config/autostart
          sudo cp installer/calamares-autostart.desktop squashfs-root/etc/skel/.config/autostart/

          # Live session: Desktop shortcut to re-launch installer
          sudo mkdir -p squashfs-root/etc/skel/Desktop
          sudo cp installer/install-lyrah.desktop squashfs-root/etc/skel/Desktop/
          sudo chmod +x squashfs-root/etc/skel/Desktop/install-lyrah.desktop

      # FIX #9: Mount virtual filesystems before chroot
      - name: Customize the system
        run: |
          echo "Customizing Lyrah OS..."
          cat > customize.sh << 'CUSTOMIZE_EOF'
          #!/usr/bin/bash
          set -e
          echo "=== Lyrah OS Customization Script ==="

          # Calamares is already installed via dnf --installroot (build step).
          # No need to run dnf inside the chroot — avoids memory pressure.

          # Base system configuration for --installroot rootfs
          echo "LANG=en_US.UTF-8" > /etc/locale.conf
          ln -sf /usr/share/zoneinfo/UTC /etc/localtime
          echo "lyrahos" > /etc/hostname

          # Update system name
          echo "Lyrah OS" > /etc/fedora-release
          echo "Lyrah OS" > /etc/redhat-release
          echo "Lyrah OS" > /etc/system-release

          # Create version file
          mkdir -p /etc
          cat > /etc/lyrah-release << RELEASE_EOF
          VERSION=@@VERSION@@
          BRANCH=@@BRANCH@@
          BUILD_DATE=$(date -u +%Y-%m-%d)
          RELEASE_EOF

          mkdir -p /usr/share/lyrah
          cat > /usr/share/lyrah/README << README_EOF
          Lyrah OS
          A Fedora-based gaming distribution.
          Luna Mode: Console-like gaming frontend (gamescope + Luna UI)
          Desktop Mode: Full KDE Plasma 6 desktop
          README_EOF

          # Create live user (passwordless, autologin)
          if ! id liveuser &>/dev/null; then
            # Ensure gamemode group exists (not present in base Fedora KDE image)
            getent group gamemode &>/dev/null || groupadd gamemode
            useradd -m -G wheel,gamemode -s /bin/bash liveuser
            passwd -d liveuser
          fi

          # Configure SDDM autologin for live session
          mkdir -p /etc/sddm.conf.d
          cat > /etc/sddm.conf.d/live-autologin.conf << SDDM_EOF
          [Autologin]
          User=liveuser
          Session=plasma
          Relogin=false
          SDDM_EOF

          # Disable screen lock and power management for live session
          mkdir -p /home/liveuser/.config
          cat > /home/liveuser/.config/kscreenlockerrc << LOCK_EOF
          [Daemon]
          Autolock=false
          LockOnResume=false
          LOCK_EOF

          cat > /home/liveuser/.config/powermanagementprofilesrc << POWER_EOF
          [AC][DPMSControl]
          idleTime=0
          [AC][SuspendSession]
          idleTime=0
          suspendType=0
          POWER_EOF

          chown -R liveuser:liveuser /home/liveuser

          # Disable SELinux for the live session.
          # The ISO remastering process (extract + repack) loses SELinux
          # xattrs. Even permissive mode floods the journal with thousands of
          # AVC denials and delays dbus-broker startup (which cascades into
          # slow SDDM/graphical session launch). Disable SELinux entirely for
          # the live session — there's no benefit when all labels are stripped.
          if [ -f /etc/selinux/config ]; then
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
            sed -i 's/SELINUX=permissive/SELINUX=disabled/' /etc/selinux/config
          fi

          # Exclude dracut livenet module — not needed for local ISO boot.
          # This config is inert during live boot (the ISO's own initramfs is
          # used), but benefits the installed system when Calamares writes to
          # disk and regenerates initramfs.
          mkdir -p /etc/dracut.conf.d
          echo 'omit_dracutmodules+=" livenet "' > /etc/dracut.conf.d/lyrah-live.conf

          # Do NOT rebuild initramfs here. The live ISO boots using the
          # initramfs from the base Fedora ISO's boot area (outside the
          # squashfs). Rebuilding dracut inside the squashfs would create a
          # mismatched initramfs that the bootloader never loads, and
          # kernel-install hooks from dnf may have already written conflicting
          # artifacts into /boot.

          # Enable SDDM — systemctl detects chroot and only creates symlinks.
          # Tolerate failure: installroot may not have full systemd paths yet.
          systemctl enable sddm 2>/dev/null || \
            ln -sf /usr/lib/systemd/system/sddm.service /etc/systemd/system/display-manager.service 2>/dev/null || true
          systemctl set-default graphical.target 2>/dev/null || \
            ln -sf /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target 2>/dev/null || true

          # Create log directories
          mkdir -p /var/log/lyrah/{luna-mode,desktop-mode}/{sessions,crashes}

          echo "Lyrah OS configured successfully"
          CUSTOMIZE_EOF

          # Substitute version/branch placeholders
          sed -i "s/@@VERSION@@/${{ steps.variant.outputs.version }}/g" customize.sh
          sed -i "s/@@BRANCH@@/${{ steps.variant.outputs.variant }}/g" customize.sh

          chmod +x customize.sh
          sudo cp customize.sh squashfs-root/

          # Ensure Fedora usr-merge symlinks exist. The 'filesystem' package
          # should create these, but --installroot inside a container may not
          # run all scriptlets. Without /bin -> usr/bin, chroot can't resolve
          # interpreters and fails with "No such file or directory" (exit 127).
          for link in bin sbin lib lib64; do
            if [ ! -e "squashfs-root/$link" ]; then
              sudo ln -sf "usr/$link" "squashfs-root/$link"
              echo "Created missing symlink: /$link -> usr/$link"
            fi
          done

          # Quick sanity check: verify bash exists inside rootfs
          if [ ! -x squashfs-root/usr/bin/bash ]; then
            echo "ERROR: /usr/bin/bash not found in rootfs — dnf install may have failed"
            ls -la squashfs-root/usr/bin/ | head -20
            exit 1
          fi
          echo "Rootfs verified: /usr/bin/bash exists"

          # Mount virtual filesystems for chroot (needed for systemctl/etc).
          # dnf --installroot does not create runtime mountpoints — create them.
          sudo mkdir -p \
            squashfs-root/proc \
            squashfs-root/sys \
            squashfs-root/dev \
            squashfs-root/dev/pts \
            squashfs-root/run
          sudo mount --bind /proc squashfs-root/proc
          sudo mount --bind /sys squashfs-root/sys
          sudo mount --bind /dev squashfs-root/dev
          sudo mount --bind /dev/pts squashfs-root/dev/pts
          sudo mount --bind /run squashfs-root/run || true

          # Provide DNS resolution inside chroot
          sudo cp /etc/resolv.conf squashfs-root/etc/resolv.conf

          echo "Memory before chroot customization:"
          free -h
          echo "---"

          sudo chroot squashfs-root /customize.sh || {
            RC=$?
            echo "=== Chroot customization failed (exit code $RC) ==="
            echo "--- dmesg (last 30 lines) ---"
            sudo dmesg | tail -30 || true
            echo "--- memory ---"
            free -h
            echo "--- cgroup memory ---"
            cat /sys/fs/cgroup/memory.max 2>/dev/null || cat /sys/fs/cgroup/memory/memory.limit_in_bytes 2>/dev/null || true
            cat /sys/fs/cgroup/memory.current 2>/dev/null || cat /sys/fs/cgroup/memory/memory.usage_in_bytes 2>/dev/null || true
            exit $RC
          }

          echo "Memory after chroot customization:"
          free -h

          # Cleanup chroot mounts
          sudo umount squashfs-root/run 2>/dev/null || true
          sudo umount squashfs-root/dev/pts
          sudo umount squashfs-root/dev
          sudo umount squashfs-root/sys
          sudo umount squashfs-root/proc
          sudo rm squashfs-root/customize.sh

      - name: Repack rootfs into SquashFS
        run: |
          echo "Repacking rootfs into SquashFS..."
          echo "Disk before repack:"
          df -h /

          SQUASHFS_PATH="iso-build/LiveOS/squashfs.img"
          sudo mkdir -p iso-build/LiveOS

          # Create SquashFS directly from squashfs-root/ directory.
          # mksquashfs reads and compresses in streaming fashion - no intermediate copy needed.
          sudo mksquashfs squashfs-root "$SQUASHFS_PATH.new" -comp xz -b 1M -xattrs

          # Clean up extracted rootfs and replace old image
          sudo rm -rf squashfs-root
          sudo rm -f "$SQUASHFS_PATH"
          sudo mv "$SQUASHFS_PATH.new" "$SQUASHFS_PATH"

          echo "Repacked SquashFS: $(ls -lh "$SQUASHFS_PATH")"
          echo "Disk after repack:"
          df -h /

      - name: Update ISO metadata
        run: |
          # Fix permissions on iso-build (EFI directory may be restrictive)
          sudo chmod -R a+rX iso-build/
          if [ -f iso-build/.discinfo ]; then
            sudo sed -i "s/Fedora/Lyrah OS/g" iso-build/.discinfo
          fi
          find iso-build -name "isolinux.cfg" -o -name "grub.cfg" | while read cfg; do
            # CRITICAL: Fix CDLABEL to match the ISO volume label set by
            # xorriso (-V "LyrahOS"). The base Fedora ISO uses something
            # like CDLABEL=Fedora-KDE-Live-43-1-6. A naive s/Fedora/Lyrah OS/
            # introduces a SPACE which breaks kernel parameter parsing and
            # the resulting label doesn't match the actual volume ID anyway.
            # Fix the label BEFORE the cosmetic rename below.
            sudo sed -i -E 's/CDLABEL=[^ "]+/CDLABEL=LyrahOS/g' "$cfg" || true
            # Disable SELinux from the kernel command line. The config-file
            # change above only takes effect after init; selinux=0 disables
            # it immediately so no AVC denials are generated at all.
            # Also add rd.live.dir=/LiveOS so dracut explicitly knows where
            # the squashfs lives — prevents mismatches when the rootfs is
            # built from scratch rather than extracted from the original ISO.
            sudo sed -i -E 's/(rd\.live\.image)/\1 rd.live.dir=\/LiveOS selinux=0/' "$cfg" || true
            # Cosmetic: rename Fedora to Lyrah OS in menu entry titles
            sudo sed -i "s/Fedora/Lyrah OS/g" "$cfg" || true
          done

      - name: Create new ISO
        run: |
          echo "Creating Lyrah OS ISO..."
          mkdir -p output
          ISO_NAME="Lyrah-OS-${{ steps.variant.outputs.version }}-${{ steps.variant.outputs.variant }}-x86_64.iso"

          # Build xorriso arguments dynamically based on available boot files
          XORRISO_ARGS=(
            -o "output/$ISO_NAME"
            -V "LyrahOS"
            -J -joliet-long -r
          )

          # Check for BIOS boot (isolinux) — not present in newer UEFI-only Fedora ISOs
          if [ -f iso-build/isolinux/isolinux.bin ]; then
            echo "Found isolinux — enabling BIOS boot"
            XORRISO_ARGS+=(
              -b isolinux/isolinux.bin
              -c isolinux/boot.cat
              -no-emul-boot
              -boot-load-size 4
              -boot-info-table
            )
            HAS_BIOS=true
          else
            echo "No isolinux found — BIOS boot disabled"
            HAS_BIOS=false
          fi

          # Check for UEFI boot
          if [ -f iso-build/images/efiboot.img ]; then
            echo "Found efiboot.img — enabling UEFI boot"
            if [ "$HAS_BIOS" = "true" ]; then
              XORRISO_ARGS+=(-eltorito-alt-boot)
            fi
            XORRISO_ARGS+=(
              -e images/efiboot.img
              -no-emul-boot
              -isohybrid-gpt-basdat
            )
          else
            echo "WARNING: No efiboot.img found — UEFI boot disabled"
          fi

          XORRISO_ARGS+=(iso-build/)

          echo "Running xorriso with args: ${XORRISO_ARGS[*]}"
          sudo xorriso -as mkisofs "${XORRISO_ARGS[@]}"

          if [ "$HAS_BIOS" = "true" ]; then
            sudo isohybrid --uefi "output/$ISO_NAME" || echo "isohybrid not available, skipping"
          fi
          ls -lh output/

      - name: Verify ISO was created
        run: |
          ISO_FILE="output/Lyrah-OS-${{ steps.variant.outputs.version }}-${{ steps.variant.outputs.variant }}-x86_64.iso"
          if [ ! -f "$ISO_FILE" ]; then
            echo "ERROR: ISO file was not created!"
            exit 1
          fi
          echo "ISO created successfully:"
          ls -lh "$ISO_FILE"
          SIZE_MB=$(du -m "$ISO_FILE" | cut -f1)
          echo "ISO size: ${SIZE_MB}MB"
          if [ $SIZE_MB -lt 100 ]; then
            echo "WARNING: ISO seems too small!"
          fi

      - name: Generate checksums
        run: |
          cd output/
          sha256sum *.iso > SHA256SUMS
          sha512sum *.iso > SHA512SUMS
          cat SHA256SUMS

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lyrah-os-${{ steps.variant.outputs.variant }}-${{ steps.variant.outputs.version }}
          path: |
            output/*.iso
            output/SHA256SUMS
            output/SHA512SUMS
          retention-days: 30

      - name: Upload to release (if tag)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            output/*.iso
            output/SHA256SUMS
            output/SHA512SUMS
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-iso:
    needs: build-iso
    runs-on: ubuntu-latest

    steps:
      - name: Download ISO
        uses: actions/download-artifact@v4
        with:
          pattern: lyrah-os-*
          merge-multiple: true

      - name: Install QEMU
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils

      - name: Test ISO boot
        run: |
          ISO_FILE=$(ls *.iso | head -1)
          echo "Testing ISO: $ISO_FILE"
          touch boot.log
          timeout 90s qemu-system-x86_64 \
            -m 2048 \
            -smp 2 \
            -cdrom "$ISO_FILE" \
            -boot d \
            -display none \
            -serial file:boot.log \
            2>&1 &
          QEMU_PID=$!
          sleep 60
          if ps -p $QEMU_PID > /dev/null 2>&1; then
            echo "ISO boots successfully (QEMU still running after 60s)"
            kill $QEMU_PID 2>/dev/null || true
            exit 0
          else
            echo "QEMU exited early (may indicate boot failure)"
            echo "Boot log:"
            cat boot.log || echo "No log captured"
            exit 0
          fi
