name: Build Lyrah OS ISO

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to build'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - testing
          - dev

env:
  FEDORA_VERSION: 43
  BASE_ISO_URL: https://download.fedoraproject.org/pub/fedora/linux/releases/43/KDE/x86_64/iso/Fedora-KDE-Desktop-Live-43-1.6.x86_64.iso

jobs:
  build-iso:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /opt/ghc
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"
          sudo rm -rf /usr/share/swift /usr/share/miniconda /usr/share/az_* /opt/hostedtoolcache
          sudo docker image prune -af 2>/dev/null || true
          echo "Available disk space:"
          sudo df -h /

      - name: Determine build variant
        id: variant
        run: |
          BRANCH="${{ github.ref_name }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            BRANCH="${{ inputs.branch }}"
          fi

          case $BRANCH in
            main)
              echo "variant=main" >> $GITHUB_OUTPUT
              echo "version=1.0.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
            testing)
              echo "variant=testing" >> $GITHUB_OUTPUT
              echo "version=1.0-beta.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
            dev)
              echo "variant=dev" >> $GITHUB_OUTPUT
              echo "version=1.0-dev.${{ github.run_number }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            genisoimage \
            xorriso \
            squashfs-tools \
            wget \
            rsync \
            zstd \
            lz4

      - name: Download base Fedora KDE ISO
        run: |
          echo "Downloading Fedora KDE Live ISO..."
          wget -O fedora-base.iso "${{ env.BASE_ISO_URL }}"
          ls -lh fedora-base.iso

      - name: Extract ISO contents
        id: extract-iso
        run: |
          echo "Extracting ISO..."
          mkdir -p iso-extract iso-build
          sudo mount -o loop fedora-base.iso iso-extract
          sudo rsync -av iso-extract/ iso-build/
          sudo umount iso-extract
          sudo chmod -R u+w iso-build/
          # Free disk: remove base ISO now that contents are extracted
          rm -f fedora-base.iso
          # Remove the squashfs/rootfs image — we build rootfs from scratch
          # with dnf --installroot instead of extracting from EROFS/SquashFS.
          # Only the boot infrastructure (EFI, grub, isolinux) is kept.
          sudo rm -f iso-build/LiveOS/squashfs.img iso-build/LiveOS/rootfs.img 2>/dev/null || true
          echo "Disk after ISO extraction (rootfs images removed):"
          df -h /

          # Detect kernel version from ISO boot area.
          # Phase 2 must install this EXACT version so modules match the
          # vmlinuz that GRUB actually boots. A mismatch means no runtime
          # module loading (no GPU drivers, no network, no sound).
          ISO_KVER=""
          for vmlinuz_path in iso-build/images/pxeboot/vmlinuz iso-build/isolinux/vmlinuz; do
            if [ -f "$vmlinuz_path" ]; then
              ISO_KVER=$(file "$vmlinuz_path" | grep -oP 'version \K\S+' || true)
              if [ -n "$ISO_KVER" ]; then
                echo "Detected ISO boot kernel: $ISO_KVER"
                break
              fi
            fi
          done
          if [ -z "$ISO_KVER" ]; then
            echo "WARNING: Could not detect ISO kernel version — phase 2 will install latest"
          fi
          echo "iso_kver=${ISO_KVER}" >> $GITHUB_OUTPUT

      # Replace Fedora Plymouth theme in the boot area initramfs with Lyrah theme.
      # The live ISO uses the base Fedora initramfs from iso-build/isolinux/ and
      # iso-build/images/pxeboot/, which has the Fedora theme embedded. This step
      # extracts the initramfs, replaces the Fedora theme with Lyrah, and repacks it.
      - name: Customize boot area Plymouth theme
        run: |
          set -euo pipefail
          echo "=== Customizing Plymouth theme in boot initramfs ==="

          # Function to extract, modify, and repack an initramfs
          customize_initramfs() {
            local initramfs_path="$1"

            if [ ! -f "$initramfs_path" ]; then
              echo "WARN: $initramfs_path not found, skipping"
              return 0
            fi

            echo "Processing: $initramfs_path"

            # Create temporary directory for extraction
            local work_dir=$(mktemp -d)
            cd "$work_dir"

            # Detect compression and extract.
            # Fedora 43+ commonly uses zstd-compressed initramfs; if we don't
            # handle that format, Fedora branding stays in place.
            initramfs_file_info=$(file "$initramfs_path")
            if echo "$initramfs_file_info" | grep -qi "zstd"; then
              echo "  Detected zstd compression"
              zstd -dc "$initramfs_path" | cpio -idm --quiet
            elif echo "$initramfs_file_info" | grep -qi "gzip"; then
              echo "  Detected gzip compression"
              gunzip -c "$initramfs_path" | cpio -idm --quiet
            elif echo "$initramfs_file_info" | grep -qi "XZ"; then
              echo "  Detected XZ compression"
              xz -dc "$initramfs_path" | cpio -idm --quiet
            elif echo "$initramfs_file_info" | grep -qi "LZ4"; then
              echo "  Detected LZ4 compression"
              lz4 -dc "$initramfs_path" | cpio -idm --quiet
            else
              echo "  Extracting as plain cpio"
              cpio -idm --quiet < "$initramfs_path"
            fi

            # Check if Plymouth theme directory exists
            if [ -d usr/share/plymouth/themes ]; then
              echo "  Found Plymouth themes directory"

              # Remove Fedora themes
              sudo rm -rf usr/share/plymouth/themes/fedora* usr/share/plymouth/themes/spinner 2>/dev/null || true
              echo "  Removed Fedora themes"

              # Add Lyrah theme
              mkdir -p usr/share/plymouth/themes/lyrah
              cp -r "${GITHUB_WORKSPACE}/themes/plymouth/lyrah/"* usr/share/plymouth/themes/lyrah/
              echo "  Added Lyrah theme"

              # Update plymouthd.conf if it exists
              if [ -f etc/plymouth/plymouthd.conf ]; then
                sed -i 's/^Theme=.*/Theme=lyrah/' etc/plymouth/plymouthd.conf
                echo "  Updated plymouthd.conf to use Lyrah theme"
              else
                # Create config if it doesn't exist
                mkdir -p etc/plymouth
                echo "[Daemon]" > etc/plymouth/plymouthd.conf
                echo "Theme=lyrah" >> etc/plymouth/plymouthd.conf
                echo "  Created plymouthd.conf with Lyrah theme"
              fi
            else
              echo "  WARN: No Plymouth themes directory found in initramfs"
            fi

            # Repack the initramfs (using gzip compression like Fedora does)
            echo "  Repacking initramfs..."
            find . -print0 | cpio -0 -o -H newc --quiet 2>/dev/null | gzip -9 > "${work_dir}/initramfs.new"

            # Replace original
            sudo cp "${work_dir}/initramfs.new" "$initramfs_path"
            echo "  Replaced $initramfs_path"

            # Cleanup
            cd /
            rm -rf "$work_dir"
            echo "  Done processing $initramfs_path"
          }

          # Process BIOS/isolinux initramfs
          customize_initramfs "${GITHUB_WORKSPACE}/iso-build/isolinux/initrd.img"

          # Process PXE boot initramfs if it exists
          customize_initramfs "${GITHUB_WORKSPACE}/iso-build/images/pxeboot/initrd.img"

          echo "=== Plymouth theme customization complete ==="

      # Swap must be expanded BEFORE rootfs build — the default runner swap
      # (3GB) is not enough for dnf dependency resolution of large package sets.
      - name: Ensure adequate swap space
        run: |
          CURRENT_SWAP_KB=$(swapon --show=SIZE --bytes --noheadings 2>/dev/null | awk '{s+=$1} END{print int(s/1024)}')
          echo "Current swap: ${CURRENT_SWAP_KB:-0} KB"
          NEED_KB=$((8 * 1024 * 1024))
          if [ "${CURRENT_SWAP_KB:-0}" -lt "$NEED_KB" ]; then
            echo "Expanding swap to 8GB..."
            sudo swapoff -a 2>/dev/null || true
            sudo rm -f /swapfile /mnt/swapfile
            sudo fallocate -l 8G /mnt/swapfile
            sudo chmod 600 /mnt/swapfile
            sudo mkswap /mnt/swapfile
            sudo swapon /mnt/swapfile
          else
            echo "Existing swap is sufficient"
          fi
          free -h

      # Build rootfs from scratch using dnf --installroot instead of
      # extracting from the Fedora ISO's EROFS/SquashFS image.
      #
      # The old approach mounted the EROFS image, which triggered OOM:
      # the kernel EROFS driver allocates non-swappable slab memory for
      # BIG_PCLUSTER decompression, exceeding the runner's cgroup limit.
      #
      # dnf --installroot avoids this entirely — it downloads and installs
      # packages in userspace with normal swappable memory.
      #
      # Phase 1: Install everything EXCEPT kernel* to keep peak memory low.
      # Phase 2: Install kernel in a separate pass after phase 1 memory is freed.
      - name: Build rootfs (phase 1 - base system, no kernel)
        run: |
          set -euo pipefail
          echo "Building rootfs from scratch using dnf --installroot..."
          echo "Phase 1: base system (excluding kernel* to avoid OOM)"
          sudo mkdir -p squashfs-root

          echo "=== Memory before phase 1 ==="
          free -h
          echo "==="

          # Use a Fedora container to run dnf --installroot.
          # The container provides Fedora repo configs; --installroot creates
          # a fresh Fedora root filesystem at the mounted /rootfs path.
          # Excluding kernel* drastically reduces peak memory — the kernel
          # package tree is the single largest contributor to dnf metadata bloat.
          # --use-host-config is REQUIRED for dnf5 (Fedora 41+).
          # Without it, dnf5 looks for repos inside the empty installroot
          # and resolves nothing. This flag tells it to use the container's
          # /etc/yum.repos.d/ and /etc/dnf/dnf.conf instead.
          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c '
              set -euo pipefail

              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                --exclude=kernel* \
                --exclude=virtualbox-guest-additions* \
                filesystem \
                setup \
                @kde-desktop-environment \
                NetworkManager \
                pipewire \
                wireplumber \
                sddm \
                gamemode \
                mangohud \
                grub2-efi-x64 \
                grub2-efi-x64-modules \
                efibootmgr \
                shim-x64 \
                plymouth \
                dracut \
                systemd \
                dnf \
                passwd \
                sudo \
                bash \
                glibc-langpack-en \
                util-linux

              dnf clean all --installroot=/rootfs

              # Verify install actually wrote files
              if [ ! -x /rootfs/usr/bin/bash ]; then
                echo "FATAL: /usr/bin/bash missing after dnf install — rootfs is empty"
                ls -la /rootfs/ || true
                exit 1
              fi
              echo "Rootfs verified inside container: /usr/bin/bash exists"
            '

          echo "Phase 1 complete. Rootfs size: $(sudo du -sh squashfs-root/ | cut -f1)"
          echo "Memory after phase 1:"
          free -h
          echo "Disk after phase 1:"
          df -h /

      - name: Install kernel into rootfs (phase 2)
        run: |
          set -euo pipefail
          echo "Phase 2: Installing kernel (separate pass to avoid OOM)..."

          echo "=== Memory before phase 2 ==="
          free -h
          echo "==="

          # Separate container run so phase 1 memory is fully released.
          # Only the kernel package tree is resolved here — much smaller
          # dependency graph than the full system.
          #
          # Use kernel-core + kernel-modules-core instead of the 'kernel'
          # meta-package. The meta-package triggers kernel-install hooks
          # that write to /boot and run grub2-mkconfig — all pointless
          # inside --installroot since boot infrastructure comes from the
          # base Fedora ISO. We only need modules for runtime hardware support.
          #
          # Pin to the ISO's kernel version so modules match the vmlinuz
          # that GRUB actually boots. A version mismatch means modprobe
          # can't find modules at runtime (no GPU, no network, no sound).
          ISO_KVER="${{ steps.extract-iso.outputs.iso_kver }}"
          KERNEL_PKGS="kernel-core kernel-modules-core"
          if [ -n "$ISO_KVER" ]; then
            # file reports: 6.x.y-z.fc43.x86_64 — strip arch suffix for dnf
            KVER_DNF="${ISO_KVER%.x86_64}"
            KVER_DNF="${KVER_DNF%.aarch64}"
            echo "Pinning kernel to ISO version: $KVER_DNF"
            KERNEL_PKGS="kernel-core-${KVER_DNF} kernel-modules-core-${KVER_DNF}"
          else
            echo "WARNING: ISO kernel version unknown — installing latest"
          fi

          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c "
              set -euo pipefail

              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                $KERNEL_PKGS

              dnf clean all --installroot=/rootfs

              # Verify kernel modules were installed
              ls /rootfs/lib/modules/ || {
                echo 'FATAL: No kernel modules found after dnf install'
                exit 1
              }
            "

          echo "Phase 2 complete. Rootfs size: $(sudo du -sh squashfs-root/ | cut -f1)"
          echo "Kernel modules installed:"
          ls squashfs-root/lib/modules/ 2>/dev/null || echo "WARNING: No kernel modules found"
          echo "Memory after phase 2:"
          free -h
          echo "Disk after phase 2:"
          df -h /
          echo "Root entries:"
          ls squashfs-root/ | head -20

      # Install Calamares in its own container run (phase 3).
      # Previously Calamares was installed inside the phase 1 container,
      # but after resolving 800+ base packages, dnf OOMs or hits conflicts
      # on the second resolution. Running in a separate container frees all
      # phase 1 memory before starting. This mirrors the kernel approach.
      - name: Install Calamares into rootfs (phase 3)
        run: |
          set -euo pipefail
          echo "Phase 3: Installing Calamares installer..."

          echo "=== Memory before phase 3 ==="
          free -h
          echo "==="

          docker run --rm \
            -v "$(pwd)/squashfs-root:/rootfs" \
            fedora:${{ env.FEDORA_VERSION }} \
            bash -c '
              set -euo pipefail

              echo "Installing Calamares..."
              dnf install -y \
                --installroot=/rootfs \
                --use-host-config \
                --releasever=${{ env.FEDORA_VERSION }} \
                --setopt=install_weak_deps=False \
                --setopt=max_parallel_downloads=2 \
                --exclude=kernel* \
                --exclude=virtualbox-guest-additions* \
                calamares

              dnf clean all --installroot=/rootfs

              # Hard verification: calamares binary must exist
              if [ ! -f /rootfs/usr/bin/calamares ]; then
                echo "FATAL: /usr/bin/calamares not found after install"
                echo "Contents of /usr/bin/calam*:"
                ls -la /rootfs/usr/bin/calam* 2>/dev/null || echo "  (none)"
                echo "RPM query:"
                rpm --root=/rootfs -q calamares 2>/dev/null || echo "  calamares not in rpm db"
                exit 1
              fi
              echo "Calamares verified: $(ls -la /rootfs/usr/bin/calamares)"
            '

          echo "Phase 3 complete. Calamares installed."
          echo "Memory after phase 3:"
          free -h

      # Copy Lyrah OS configs into rootfs before chroot
      - name: Stage Lyrah OS files
        run: |
          echo "Staging Lyrah OS files into rootfs..."

          # Calamares config and branding
          sudo mkdir -p squashfs-root/etc/calamares
          sudo cp -r installer/calamares/settings.conf squashfs-root/etc/calamares/
          sudo cp -r installer/calamares/modules squashfs-root/etc/calamares/
          sudo mkdir -p squashfs-root/usr/share/calamares/branding/lyrah
          sudo cp -r installer/calamares/branding/lyrah/* squashfs-root/usr/share/calamares/branding/lyrah/

          # Session desktop files
          sudo mkdir -p squashfs-root/usr/share/wayland-sessions
          sudo cp configs/luna-mode/luna-mode.desktop squashfs-root/usr/share/wayland-sessions/
          sudo cp configs/desktop-mode/plasma.desktop squashfs-root/usr/share/wayland-sessions/

          # SDDM theme
          sudo mkdir -p squashfs-root/usr/share/sddm/themes/lyrah-space
          sudo cp -r themes/sddm/lyrah-space/* squashfs-root/usr/share/sddm/themes/lyrah-space/

          # SDDM config (lyrah theme as default)
          sudo mkdir -p squashfs-root/etc/sddm.conf.d
          sudo cp configs/common/lyrah.conf squashfs-root/etc/sddm.conf.d/lyrah.conf

          # Plymouth theme
          sudo mkdir -p squashfs-root/usr/share/plymouth/themes/lyrah
          sudo cp -r themes/plymouth/lyrah/* squashfs-root/usr/share/plymouth/themes/lyrah/
          # Set Lyrah as the default Plymouth theme. This updates
          # /etc/plymouth/plymouthd.conf inside the squashfs. We don't
          # rebuild initramfs here (the live ISO uses Fedora's initramfs
          # from the boot area), but this ensures the theme is active for
          # the installed system and any live boot Plymouth displays.
          sudo chroot squashfs-root /bin/bash -c "plymouth-set-default-theme lyrah" 2>/dev/null || echo "WARN: Could not set Plymouth theme (non-fatal)"

          # Scripts
          sudo mkdir -p squashfs-root/usr/share/lyrah/setup
          sudo cp scripts/first-boot.sh squashfs-root/usr/share/lyrah/setup/
          sudo cp scripts/configure-gpu.sh squashfs-root/usr/share/lyrah/setup/
          sudo chmod +x squashfs-root/usr/share/lyrah/setup/*.sh

          sudo mkdir -p squashfs-root/usr/bin
          sudo cp scripts/luna-session squashfs-root/usr/bin/
          sudo cp scripts/lyrah-installer-session squashfs-root/usr/bin/
          sudo cp scripts/lyrah-switch-mode squashfs-root/usr/bin/
          sudo cp scripts/lyrah-configure-autologin squashfs-root/usr/bin/
          sudo cp scripts/lyrah-update squashfs-root/usr/bin/
          sudo cp scripts/lyrah-upload-log squashfs-root/usr/bin/
          sudo cp scripts/lyrah-crash-monitor squashfs-root/usr/bin/
          sudo chmod +x squashfs-root/usr/bin/luna-session squashfs-root/usr/bin/lyrah-*

          # Installer session .desktop (SDDM can select this as a session)
          sudo cp installer/lyrah-installer.desktop squashfs-root/usr/share/wayland-sessions/

          # Systemd units
          sudo cp system/*.service system/*.timer squashfs-root/etc/systemd/system/ 2>/dev/null || true

          # Remove Fedora EFI files from rootfs.
          # The grub2-efi-x64 and shim-x64 RPMs install a GRUB binary and
          # redirect grub.cfg into /boot/efi/EFI/fedora/. If these ship in
          # the squashfs, Calamares copies them to the real ESP and the
          # firmware shows a duplicate "Fedora" boot entry with stale UUIDs
          # that either hangs at a GRUB shell or fails to find the kernel.
          # Calamares's bootloader module re-installs GRUB properly via
          # grub2-install, so these pre-packaged files are never needed.
          sudo rm -rf squashfs-root/boot/efi/EFI/fedora
          echo "Removed stale Fedora EFI directory from rootfs"

          # Post-install scripts for Calamares shellprocess
          sudo mkdir -p squashfs-root/usr/share/lyrah/installer
          sudo cp installer/scripts/post-install.sh squashfs-root/usr/share/lyrah/installer/
          sudo cp installer/scripts/configure-session.sh squashfs-root/usr/share/lyrah/installer/
          sudo cp installer/scripts/setup-kernel.sh squashfs-root/usr/share/lyrah/installer/
          sudo chmod +x squashfs-root/usr/share/lyrah/installer/*.sh

          # Wine env config
          sudo mkdir -p squashfs-root/etc/profile.d
          sudo cp configs/common/lyrah-wine.sh squashfs-root/etc/profile.d/

          # Logrotate
          sudo mkdir -p squashfs-root/etc/logrotate.d
          sudo cp logging/logrotate-lyrah.conf squashfs-root/etc/logrotate.d/lyrah

          # Live session: Desktop shortcut to launch installer if user
          # switches to the Plasma session from SDDM
          sudo mkdir -p squashfs-root/etc/skel/Desktop
          sudo cp installer/install-lyrah.desktop squashfs-root/etc/skel/Desktop/
          sudo chmod +x squashfs-root/etc/skel/Desktop/install-lyrah.desktop

      # FIX #9: Mount virtual filesystems before chroot
      - name: Customize the system
        run: |
          echo "Customizing Lyrah OS..."
          cat > customize.sh << 'CUSTOMIZE_EOF'
          #!/usr/bin/bash
          set -e
          echo "=== Lyrah OS Customization Script ==="

          # Calamares is already installed via dnf --installroot (build step).
          # No need to run dnf inside the chroot — avoids memory pressure.

          # Base system configuration for --installroot rootfs
          echo "LANG=en_US.UTF-8" > /etc/locale.conf
          ln -sf /usr/share/zoneinfo/UTC /etc/localtime
          echo "lyrahos" > /etc/hostname

          # Update system name
          echo "Lyrah OS" > /etc/fedora-release
          echo "Lyrah OS" > /etc/redhat-release
          echo "Lyrah OS" > /etc/system-release

          # Create version file
          mkdir -p /etc
          cat > /etc/lyrah-release << RELEASE_EOF
          VERSION=@@VERSION@@
          BRANCH=@@BRANCH@@
          BUILD_DATE=$(date -u +%Y-%m-%d)
          RELEASE_EOF

          mkdir -p /usr/share/lyrah
          cat > /usr/share/lyrah/README << README_EOF
          Lyrah OS
          A Fedora-based gaming distribution.
          Luna Mode: Console-like gaming frontend (gamescope + Luna UI)
          Desktop Mode: Full KDE Plasma 6 desktop
          README_EOF

          # Create live user (passwordless, autologin)
          if ! id liveuser &>/dev/null; then
            # Ensure gamemode group exists (not present in base Fedora KDE image)
            getent group gamemode &>/dev/null || groupadd gamemode
            useradd -m -G wheel,gamemode -s /bin/bash liveuser
            passwd -d liveuser
          fi

          # Passwordless sudo for the live session.
          # Without this, the Calamares autostart (sudo -E calamares) fails
          # silently because there is no terminal to enter a password.
          echo "liveuser ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/liveuser
          chmod 440 /etc/sudoers.d/liveuser

          # Configure SDDM autologin for live session
          mkdir -p /etc/sddm.conf.d
          cat > /etc/sddm.conf.d/live-autologin.conf << SDDM_EOF
          [Autologin]
          User=liveuser
          Session=lyrah-installer
          Relogin=false
          SDDM_EOF

          # Disable screen lock and power management for live session
          mkdir -p /home/liveuser/.config
          cat > /home/liveuser/.config/kscreenlockerrc << LOCK_EOF
          [Daemon]
          Autolock=false
          LockOnResume=false
          LOCK_EOF

          cat > /home/liveuser/.config/powermanagementprofilesrc << POWER_EOF
          [AC][DPMSControl]
          idleTime=0
          [AC][SuspendSession]
          idleTime=0
          suspendType=0
          POWER_EOF

          chown -R liveuser:liveuser /home/liveuser

          # Disable SELinux for the live session.
          # The ISO remastering process (extract + repack) loses SELinux
          # xattrs. Even permissive mode floods the journal with thousands of
          # AVC denials and delays dbus-broker startup (which cascades into
          # slow SDDM/graphical session launch). Disable SELinux entirely for
          # the live session — there's no benefit when all labels are stripped.
          if [ -f /etc/selinux/config ]; then
            sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
            sed -i 's/SELINUX=permissive/SELINUX=disabled/' /etc/selinux/config
          fi

          # Exclude dracut livenet module — not needed for local ISO boot.
          # This config is inert during live boot (the ISO's own initramfs is
          # used), but benefits the installed system when Calamares writes to
          # disk and regenerates initramfs.
          mkdir -p /etc/dracut.conf.d
          echo 'omit_dracutmodules+=" livenet "' > /etc/dracut.conf.d/lyrah-live.conf

          # Do NOT rebuild initramfs here. The live ISO boots using the
          # initramfs from the base Fedora ISO's boot area (outside the
          # squashfs). Rebuilding dracut inside the squashfs would create a
          # mismatched initramfs that the bootloader never loads, and
          # kernel-install hooks from dnf may have already written conflicting
          # artifacts into /boot.

          # Enable SDDM — systemctl detects chroot and only creates symlinks.
          # Tolerate failure: installroot may not have full systemd paths yet.
          systemctl enable sddm 2>/dev/null || \
            ln -sf /usr/lib/systemd/system/sddm.service /etc/systemd/system/display-manager.service 2>/dev/null || true
          systemctl set-default graphical.target 2>/dev/null || \
            ln -sf /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target 2>/dev/null || true

          # Create log directories
          mkdir -p /var/log/lyrah/{luna-mode,desktop-mode}/{sessions,crashes}

          echo "Lyrah OS configured successfully"
          CUSTOMIZE_EOF

          # Substitute version/branch placeholders
          sed -i "s/@@VERSION@@/${{ steps.variant.outputs.version }}/g" customize.sh
          sed -i "s/@@BRANCH@@/${{ steps.variant.outputs.variant }}/g" customize.sh

          chmod +x customize.sh
          sudo cp customize.sh squashfs-root/

          # Ensure Fedora usr-merge symlinks exist. The 'filesystem' package
          # should create these, but --installroot inside a container may not
          # run all scriptlets. Without /bin -> usr/bin, chroot can't resolve
          # interpreters and fails with "No such file or directory" (exit 127).
          for link in bin sbin lib lib64; do
            if [ ! -e "squashfs-root/$link" ]; then
              sudo ln -sf "usr/$link" "squashfs-root/$link"
              echo "Created missing symlink: /$link -> usr/$link"
            fi
          done

          # Quick sanity check: verify bash exists inside rootfs
          if [ ! -x squashfs-root/usr/bin/bash ]; then
            echo "ERROR: /usr/bin/bash not found in rootfs — dnf install may have failed"
            ls -la squashfs-root/usr/bin/ | head -20
            exit 1
          fi
          echo "Rootfs verified: /usr/bin/bash exists"

          # Mount virtual filesystems for chroot (needed for systemctl/etc).
          # dnf --installroot does not create runtime mountpoints — create them.
          sudo mkdir -p \
            squashfs-root/proc \
            squashfs-root/sys \
            squashfs-root/dev \
            squashfs-root/dev/pts \
            squashfs-root/run
          sudo mount --bind /proc squashfs-root/proc
          sudo mount --bind /sys squashfs-root/sys
          sudo mount --bind /dev squashfs-root/dev
          sudo mount --bind /dev/pts squashfs-root/dev/pts
          sudo mount --bind /run squashfs-root/run || true

          # Provide DNS resolution inside chroot.
          # systemd installs /etc/resolv.conf as a symlink to
          # ../run/systemd/resolve/stub-resolv.conf. After bind-mounting
          # /run above, that symlink resolves to the host's resolv.conf,
          # so cp fails with "same file". Remove the symlink first.
          sudo rm -f squashfs-root/etc/resolv.conf
          sudo cp /etc/resolv.conf squashfs-root/etc/resolv.conf

          echo "Memory before chroot customization:"
          free -h
          echo "---"

          sudo chroot squashfs-root /customize.sh || {
            RC=$?
            echo "=== Chroot customization failed (exit code $RC) ==="
            echo "--- dmesg (last 30 lines) ---"
            sudo dmesg | tail -30 || true
            echo "--- memory ---"
            free -h
            echo "--- cgroup memory ---"
            cat /sys/fs/cgroup/memory.max 2>/dev/null || cat /sys/fs/cgroup/memory/memory.limit_in_bytes 2>/dev/null || true
            cat /sys/fs/cgroup/memory.current 2>/dev/null || cat /sys/fs/cgroup/memory/memory.usage_in_bytes 2>/dev/null || true
            exit $RC
          }

          echo "Memory after chroot customization:"
          free -h

          # Cleanup chroot mounts
          sudo umount squashfs-root/run 2>/dev/null || true
          sudo umount squashfs-root/dev/pts
          sudo umount squashfs-root/dev
          sudo umount squashfs-root/sys
          sudo umount squashfs-root/proc
          sudo rm squashfs-root/customize.sh

      - name: Repack rootfs into SquashFS
        run: |
          echo "Repacking rootfs into SquashFS..."
          echo "Disk before repack:"
          df -h /

          SQUASHFS_PATH="iso-build/LiveOS/squashfs.img"
          sudo mkdir -p iso-build/LiveOS

          # Create SquashFS directly from squashfs-root/ directory.
          # mksquashfs reads and compresses in streaming fashion - no intermediate copy needed.
          sudo mksquashfs squashfs-root "$SQUASHFS_PATH.new" -comp xz -b 1M -xattrs

          # Clean up extracted rootfs and replace old image
          sudo rm -rf squashfs-root
          sudo rm -f "$SQUASHFS_PATH"
          sudo mv "$SQUASHFS_PATH.new" "$SQUASHFS_PATH"

          echo "Repacked SquashFS: $(ls -lh "$SQUASHFS_PATH")"
          echo "Disk after repack:"
          df -h /

      - name: Update ISO metadata
        run: |
          # Fix permissions on iso-build (EFI directory may be restrictive)
          sudo chmod -R a+rX iso-build/
          if [ -f iso-build/.discinfo ]; then
            sudo sed -i "s/Fedora/Lyrah OS/g" iso-build/.discinfo
          fi
          find iso-build -name "isolinux.cfg" -o -name "grub.cfg" | while read cfg; do
            # CRITICAL: Fix CDLABEL to match the ISO volume label set by
            # xorriso (-V "LyrahOS"). The base Fedora ISO uses something
            # like CDLABEL=Fedora-KDE-Live-43-1-6. A naive s/Fedora/Lyrah OS/
            # introduces a SPACE which breaks kernel parameter parsing and
            # the resulting label doesn't match the actual volume ID anyway.
            # Fix the label BEFORE the cosmetic rename below.
            sudo sed -i -E 's/CDLABEL=[^ "]+/CDLABEL=LyrahOS/g' "$cfg" || true
            # Disable SELinux from the kernel command line. The config-file
            # change above only takes effect after init; selinux=0 disables
            # it immediately so no AVC denials are generated at all.
            # Also add rd.live.dir=/LiveOS so dracut explicitly knows where
            # the squashfs lives — prevents mismatches when the rootfs is
            # built from scratch rather than extracted from the original ISO.
            # Add Plymouth splash parameters for smooth boot experience.
            sudo sed -i -E 's/(rd\.live\.image)/\1 rd.live.dir=\/LiveOS selinux=0 splash plymouth.enable=1/' "$cfg" || true
            # Cosmetic: rename Fedora to Lyrah OS in menu entry titles
            sudo sed -i "s/Fedora/Lyrah OS/g" "$cfg" || true
          done

          # Skip the boot menu entirely — boot straight into the live
          # session / installer instead of showing the Fedora "press any
          # key" splash with KDE desktop / media testing options.
          # ISOLINUX (BIOS boot): set timeout to 1 decisecond (instant),
          # disable the "press any key" prompt, default to first entry.
          # Note: isolinux keywords are case-insensitive; Fedora uses
          # uppercase (TIMEOUT, PROMPT). The sed I flag handles both.
          find iso-build -name "isolinux.cfg" | while read cfg; do
            sudo sed -i 's/^[Tt][Ii][Mm][Ee][Oo][Uu][Tt] .*/timeout 1/' "$cfg" || true
            sudo sed -i 's/^[Tt][Oo][Tt][Aa][Ll][Tt][Ii][Mm][Ee][Oo][Uu][Tt] .*/totaltimeout 1/' "$cfg" || true
            if grep -qi '^prompt ' "$cfg" 2>/dev/null; then
              sudo sed -i 's/^[Pp][Rr][Oo][Mm][Pp][Tt] .*/prompt 0/' "$cfg" || true
            else
              echo "prompt 0" | sudo tee -a "$cfg" > /dev/null
            fi
          done
          # GRUB (UEFI boot): force immediate boot into the first entry and
          # suppress interactive prompts/menu flashes as much as possible.
          find iso-build -name "grub.cfg" | while read cfg; do
            sudo sed -i -E 's/^(\s*)set timeout=.*/\1set timeout=0/' "$cfg" || true
            sudo sed -i -E 's/^(\s*)set default=.*/\1set default=0/' "$cfg" || true
            # Hide the menu entirely (prevents brief flash before timeout)
            if grep -q 'set timeout_style=' "$cfg" 2>/dev/null; then
              sudo sed -i -E 's/set timeout_style=.*/set timeout_style=hidden/' "$cfg" || true
            else
              sudo sed -i -E '/^set timeout=0/a set timeout_style=hidden' "$cfg" || true
            fi
            # Some Fedora EFI configs include an interruptible sleep with
            # "Press any key ... system reset" messaging before GRUB menu.
            # Force that path to be non-blocking.
            sudo sed -i -E '/system reset/I d' "$cfg" || true
            sudo sed -i -E 's/sleep --interruptible [0-9]+/sleep 0/g' "$cfg" || true
            sudo sed -i -E 's/sleep -i [0-9]+/sleep 0/g' "$cfg" || true
            # Force console terminal mode instead of gfxterm to minimize
            # blue screen flash during GRUB → kernel transition.
            if ! grep -q 'terminal_output console' "$cfg" 2>/dev/null; then
              sudo sed -i -E '/^set timeout=0/i terminal_output console' "$cfg" || true
            fi
          done

      - name: Create new ISO
        run: |
          echo "Creating Lyrah OS ISO..."
          mkdir -p output
          ISO_NAME="Lyrah-OS-${{ steps.variant.outputs.version }}-${{ steps.variant.outputs.variant }}-x86_64.iso"

          # Build xorriso arguments dynamically based on available boot files
          XORRISO_ARGS=(
            -o "output/$ISO_NAME"
            -V "LyrahOS"
            -J -joliet-long -r
          )

          # Check for BIOS boot (isolinux) — not present in newer UEFI-only Fedora ISOs
          if [ -f iso-build/isolinux/isolinux.bin ]; then
            echo "Found isolinux — enabling BIOS boot"
            XORRISO_ARGS+=(
              -b isolinux/isolinux.bin
              -c isolinux/boot.cat
              -no-emul-boot
              -boot-load-size 4
              -boot-info-table
            )
            HAS_BIOS=true
          else
            echo "No isolinux found — BIOS boot disabled"
            HAS_BIOS=false
          fi

          # Check for UEFI boot
          if [ -f iso-build/images/efiboot.img ]; then
            echo "Found efiboot.img — enabling UEFI boot"
            if [ "$HAS_BIOS" = "true" ]; then
              XORRISO_ARGS+=(-eltorito-alt-boot)
            fi
            XORRISO_ARGS+=(
              -e images/efiboot.img
              -no-emul-boot
              -isohybrid-gpt-basdat
            )
          else
            echo "WARNING: No efiboot.img found — UEFI boot disabled"
          fi

          XORRISO_ARGS+=(iso-build/)

          echo "Running xorriso with args: ${XORRISO_ARGS[*]}"
          sudo xorriso -as mkisofs "${XORRISO_ARGS[@]}"

          if [ "$HAS_BIOS" = "true" ]; then
            sudo isohybrid --uefi "output/$ISO_NAME" || echo "isohybrid not available, skipping"
          fi
          ls -lh output/

      - name: Verify ISO was created
        run: |
          ISO_FILE="output/Lyrah-OS-${{ steps.variant.outputs.version }}-${{ steps.variant.outputs.variant }}-x86_64.iso"
          if [ ! -f "$ISO_FILE" ]; then
            echo "ERROR: ISO file was not created!"
            exit 1
          fi
          echo "ISO created successfully:"
          ls -lh "$ISO_FILE"
          SIZE_MB=$(du -m "$ISO_FILE" | cut -f1)
          echo "ISO size: ${SIZE_MB}MB"
          if [ $SIZE_MB -lt 100 ]; then
            echo "WARNING: ISO seems too small!"
          fi

      - name: Generate checksums
        run: |
          cd output/
          sha256sum *.iso > SHA256SUMS
          sha512sum *.iso > SHA512SUMS
          cat SHA256SUMS

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lyrah-os-${{ steps.variant.outputs.variant }}-${{ steps.variant.outputs.version }}
          path: |
            output/*.iso
            output/SHA256SUMS
            output/SHA512SUMS
          retention-days: 30

      - name: Upload to release (if tag)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            output/*.iso
            output/SHA256SUMS
            output/SHA512SUMS
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  test-iso:
    needs: build-iso
    runs-on: ubuntu-latest

    steps:
      - name: Download ISO
        uses: actions/download-artifact@v4
        with:
          pattern: lyrah-os-*
          merge-multiple: true

      - name: Install QEMU
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-system-x86 qemu-utils

      - name: Test ISO boot
        run: |
          ISO_FILE=$(ls *.iso | head -1)
          echo "Testing ISO: $ISO_FILE"
          touch boot.log
          timeout 90s qemu-system-x86_64 \
            -m 2048 \
            -smp 2 \
            -cdrom "$ISO_FILE" \
            -boot d \
            -display none \
            -serial file:boot.log \
            2>&1 &
          QEMU_PID=$!
          sleep 60
          if ps -p $QEMU_PID > /dev/null 2>&1; then
            echo "ISO boots successfully (QEMU still running after 60s)"
            kill $QEMU_PID 2>/dev/null || true
            exit 0
          else
            echo "QEMU exited early (may indicate boot failure)"
            echo "Boot log:"
            cat boot.log || echo "No log captured"
            exit 0
          fi
